<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Javascript中的模块化]]></title>
      <url>/2020/11/26/Javascript%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="javascript模块化开发"><a href="#javascript模块化开发" class="headerlink" title="javascript模块化开发"></a>javascript模块化开发</h2><p>​    众所周知，早期的javascript大多情况被用来做表单验证或动画实现，通常情况下短短几行代码就可以搞定。一般情况下都被写在<script>标签里面。</p>
<p>​    但是随着前端和JavaScript的快速发展，JavaScript代码变得越来越复杂，从Ajax的出现，到后来的前后端分离，再到现在的SPA应用，前端页面正在变的越来越复杂，而没有”模块化“这件事，在很长一段时间都是javascript的硬伤</p>
<h4 id="没有模块化会引发的问题"><a href="#没有模块化会引发的问题" class="headerlink" title="没有模块化会引发的问题"></a>没有模块化会引发的问题</h4><ol>
<li>我必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用； </li>
<li>代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写；</li>
<li>第三，在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况</li>
</ol>
<h4 id="前端众多的模块化解决方案"><a href="#前端众多的模块化解决方案" class="headerlink" title="前端众多的模块化解决方案"></a>前端众多的模块化解决方案</h4><p>JavaScript社区为了解决上面的问题，涌现出一系列好用的规范</p>
<p>例如：</p>
<ul>
<li>CommonJs</li>
<li>AMD</li>
<li>CMD</li>
<li>ES module</li>
</ul>
<p>由于AMD和CMD现在应用的地方并不是很多，所以本文主要针对<strong>CommonJS</strong>的模块化进行介绍，也会对<strong>ES Module</strong>进行简要介绍</p>
<h2 id="CommonJS和Node"><a href="#CommonJS和Node" class="headerlink" title="CommonJS和Node"></a>CommonJS和Node</h2><p> 我们需要知道<code>CommonJS</code>是一个规范，最初提出来是在浏览器以外的地方使用，并且当时被命名为<code>ServerJS</code>，后来为了 体现它的广泛性，修改为<code>CommonJS</code>，平时我们也会简称为<code>CJS</code>。</p>
<ul>
<li><code>Node</code>是<code>CommonJS</code>在服务器端一个具有代表性的实现； </li>
<li><code>Browserify</code>是<code>CommonJS</code>在浏览器中的一种实现；</li>
<li><code>webpack</code>打包工具具备对<code>CommonJS</code>的支持和转换；</li>
</ul>
<p>由于Node对CommonJS进行了支持和实现，所以我们可以在开发中很方便的进行模块化开发，我们要特别注意两点</p>
<ul>
<li>在Node中每一个js文件都是一个单独的模块；</li>
<li>这个模块中包括CommonJS规范的核心变量：exports、module.exports、require；</li>
</ul>
<h4 id="Node模块化的导入和导出"><a href="#Node模块化的导入和导出" class="headerlink" title="Node模块化的导入和导出"></a>Node模块化的导入和导出</h4><p>其中<code>exports</code>和<code>module.exports</code>可以负责对模块中的内容进行导出； </p>
<p><code>require</code>函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容；</p>
<h4 id="exports与require"><a href="#exports与require" class="headerlink" title="exports与require"></a>exports与require</h4><p>下图短短几行代码，就是对Node模块化的体现~</p>
<p>exports的本质是一个对象（如图）。</p>
<p>在1.js文件中</p>
<ul>
<li>通过.的方式动态的为exports这个对象添加属性，将该对象导出该模块</li>
<li>蓝色框中代表的是被导出的属性名，<strong>可以为任意值。</strong></li>
</ul>
<p>在2.js文件中</p>
<ul>
<li>通过data来对require函数的返回值进行接收，<strong>实际上：接受到的data值实际就是导出的exports对象</strong>！相信很多人看到这个结论都是疑惑的。那我们不妨论证一下这个观点。</li>
</ul>
<img src="/2020/11/26/Javascript中的模块化/1.png" title="This is an example image">

<h4 id="验证require函数的返回值是否与exports相等"><a href="#验证require函数的返回值是否与exports相等" class="headerlink" title="验证require函数的返回值是否与exports相等"></a>验证require函数的返回值是否与exports相等</h4><p>如上图所示：</p>
<ol>
<li>首先我们先将name,age两个变量分别导出，然后在2.js中进行引入，</li>
<li>打印结果，然后在1s之后给data的name属性重新赋值</li>
<li>在2s后重新打印1.js中exports这个对象的值，</li>
<li>如果exports这个对象的name属性被重新赋值，就说明require函数的返回值与exports这个对象指向的是同一个地址</li>
</ol>
<img src="/2020/11/26/Javascript中的模块化/2.png" title="This is an example image">



<h4 id="画图解析上图代码"><a href="#画图解析上图代码" class="headerlink" title="画图解析上图代码"></a>画图解析上图代码</h4><img src="/2020/11/26/Javascript中的模块化/3.png" title="This is an example image">



<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>exports被重新赋值，说明exports对象和require函数的返回值指向同一个引用地址（浅拷贝）。</p>
<p>到这里我们已经看似完成了模块化的两个关键因素，导入和导出，那么<code>module.exports</code>又是什么呢？它和<code>exports</code>又有什么区别呢？让我们接着往下看。</p>
<h4 id="module-exports"><a href="#module-exports" class="headerlink" title="module.exports"></a>module.exports</h4><p>首先，我们要知道<code>CommonJS规范</code>中是没有<code>module.exports</code>这个概念的，</p>
<p>Node在实现的过程中使用的是<code>Module类</code>，每一个模块都是<code>Module</code>的一个实例，我们可以尝试打印一下这个属性（如下图所示），它的默认值是<code>{}</code>,</p>
<img src="/2020/11/26/Javascript中的模块化/4.png" title="This is an example image">

<p>在很多时候我们发现<code>module.exports={name}</code>和<code>exports.name=name</code>这两种导出方式，都可以实现，除了语法之外，二者几乎并无区别，都完成了导出这件事，并且通过下图这种方式我们还可以得知module.exports===exports===2.js中的data，三者指向同一个引用地址</p>
<img src="/2020/11/26/Javascript中的模块化/5.png" title="This is an example image">



<p>但是有一件事还没有确定，那就是module.exports和exports到底是谁真正的实现了Node的模块化导出，我们可以做一个实验，<strong>注意看下面两段代码</strong>！！！</p>
<img src="/2020/11/26/Javascript中的模块化/6.png" title="This is an example image">

<h5 id="第一种操作："><a href="#第一种操作：" class="headerlink" title="第一种操作："></a>第一种操作：</h5><ol>
<li>给<code>module.exports</code>赋值为<code>{}</code></li>
<li>通过exports进行导出</li>
<li>输出结果为{}</li>
</ol>
<p>说明虽然exports在后面进行导出，但仍然被前面的<code>module.exports</code>给覆盖掉了</p>
<img src="/2020/11/26/Javascript中的模块化/7.png" title="This is an example image">

<h5 id="第二种操作"><a href="#第二种操作" class="headerlink" title="第二种操作:"></a>第二种操作:</h5><ol>
<li>先给exports的值设置为{}，</li>
<li>用<code>module.exports</code>导出变量，</li>
<li>仍然可以导出成功变量。</li>
</ol>
<h4 id="为什么第一种操作中，exports会被module-exports覆盖掉？"><a href="#为什么第一种操作中，exports会被module-exports覆盖掉？" class="headerlink" title="为什么第一种操作中，exports会被module.exports覆盖掉？"></a>为什么第一种操作中，exports会被module.exports覆盖掉？</h4><p>结合图片（图没画好。。）我们可以看出，第二步的时候module.exports改变了引用地址，所以不管exports的值再怎么变化，也不会影响导出的结果。</p>
<img src="/2020/11/26/Javascript中的模块化/8.png" title="This is an example image">





<h4 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h4><p><strong>所以在Node中真正实现导出的是<code>module.exports</code></strong>,而不是<strong><code>exports</code></strong>  ，也就是<strong><code>exports=module.exports</code></strong>,并且这个操作是在模块开始加载的时候就被执行了。</p>
<h2 id="require中的细节"><a href="#require中的细节" class="headerlink" title="require中的细节"></a>require中的细节</h2><p>介绍了这么多的模块的导出，接下来讲一下<code>require</code>导入的细节，我们知道<code>require</code>是一个函数，可以帮助我们引入一个文件（模块）中导入的对象，那么<code>require</code>的查找规则到底是怎么样的呢？</p>
<p>暂且假定require(X)</p>
<h4 id="情况一：核心模块"><a href="#情况一：核心模块" class="headerlink" title="情况一：核心模块"></a>情况一：核心模块</h4><p>X是一个核心模块，比如path，http</p>
<ul>
<li>直接返回核心模块停止查找</li>
</ul>
<p>如果你想引入一个和核心模块相同名字的自定义模块的时候，你是不成功的，如果想要成功就必须换一个名字，</p>
<h4 id="情况二：路径形式的文件模块"><a href="#情况二：路径形式的文件模块" class="headerlink" title="情况二：路径形式的文件模块"></a>情况二：路径形式的文件模块</h4><p>X是以./或者../或者/（根目录开头的）</p>
<p><strong>第一步：将X当做一个文件在对应的目录下查找</strong></p>
<ol>
<li>如果有后缀名，直接按照文件路径查找对应的文件</li>
<li>如果没有后缀名，会按照如下顺序<ol>
<li>直接查找文件X（无后缀）</li>
<li>查找X.js文件</li>
<li>查找X.json文件</li>
<li>查找X.node文件</li>
</ol>
</li>
</ol>
<p>**第二步：没有找到对应的文件，将X作为一个目录</p>
<ul>
<li><p>查找目录下面的index文件</p>
<ol>
<li>查找X/index.js文件 </li>
<li>查找X/index.json文件 </li>
<li>查找X/index.node文件 </li>
</ol>
<p>如果仍然没找到，那么报错not found</p>
</li>
</ul>
<h4 id="情况三：自定义模块"><a href="#情况三：自定义模块" class="headerlink" title="情况三：自定义模块"></a>情况三：自定义模块</h4><p>直接是一个X（没有路径），并且X不是一个核心模块，也可以称为<strong>自定义模块</strong></p>
<p>查找顺序：首先查找当前目录下的node_modules目录，然后查找父级....沿路径向上依次递归，直到根目录下的node_modules目录，该查找方式与javascript的原型链/作用域链查找方式十分类似，由此也可以看出，模块的路径越深，模块查找的耗时也就越多，这也是自定义模块加载速度是最慢的原因。</p>
<p>ps:(图中的paths，是module中的属性)</p>
<img src="/2020/11/26/Javascript中的模块化/9.png" title="This is an example image">

<h4 id="情况四（特殊）：优先从缓存加载"><a href="#情况四（特殊）：优先从缓存加载" class="headerlink" title="情况四（特殊）：优先从缓存加载"></a>情况四（特殊）：优先从缓存加载</h4><p>除了以上三种情况之外，我们还需要知晓一点，与前端浏览器会缓存静态脚本文件以提高性能一样，Node对引入过的模块都会进行缓存，以减少二次引用的开销，</p>
<h4 id="几种情况的加载速度对比"><a href="#几种情况的加载速度对比" class="headerlink" title="几种情况的加载速度对比"></a>几种情况的加载速度对比</h4><ol>
<li>不管是核心模块还是文件模块，require对于相同模块的二次加载都一律采用<strong>缓存加载优先</strong>的方式，所以属于第一优先级。</li>
<li>而Node核心模块在Node源代码编译过程中，编译进了二进制执行文件</li>
<li>以路径形式的文件模块，以路径作为路引进行查找，由于给定了明确的文件位置，所以也可以节约大量的时间，慢于核心模块</li>
<li>由于既不是核心模块，也没有详细的地址，所以这类文件查找起来是最费时的</li>
</ol>
<p><strong>缓存加载>核心模块>路径形式的文件模块>自定义模块</strong></p>
<h4 id="分析模块的加载过程"><a href="#分析模块的加载过程" class="headerlink" title="分析模块的加载过程"></a>分析模块的加载过程</h4><ul>
<li>如果模块被循环引入，那么加载顺序是什么？让我们看下下面这段代码</li>
</ul>
<img src="/2020/11/26/Javascript中的模块化/10.png" title="This is an example image">

<p>涉及的文件太多，所以我把它抽象成图看起来会清晰一些</p>
<img src="/2020/11/26/Javascript中的模块化/11.png" title="This is an example image">

<ul>
<li>这个其实是一种数据结构：图结构； </li>
<li>图结构在遍历的过程中，有深度优先搜索（DFS, depth first search）和广度优先搜索（BFS, breadth first search）；</li>
<li>Node采用的是深度优先算法：aaa -> ccc -> ddd -> eee ->bbb</li>
</ul>
<p><strong>所以根据上图，我们知道同一个模块不会被重复加载，并且在模块被循环引用时，会根据深度优先进行引入</strong></p>
<h4 id="问题：模块被多次引入时-为什么只会加载运行一次呢？"><a href="#问题：模块被多次引入时-为什么只会加载运行一次呢？" class="headerlink" title="问题：模块被多次引入时  为什么只会加载运行一次呢？"></a>问题：模块被多次引入时  为什么只会加载运行一次呢？</h4><ul>
<li>这是因为每个模块对象module都有一个属性：loaded。 </li>
<li>当load 为false表示还没有加载，为true表示已经加载；</li>
</ul>
<h4 id="CommonJS规范缺点"><a href="#CommonJS规范缺点" class="headerlink" title="CommonJS规范缺点"></a>CommonJS规范缺点</h4><img src="/2020/11/26/Javascript中的模块化/12.png" title="This is an example image">

<p>由图可知在2.js中引用了1.js，而打印的顺序是先执行1.js，之后再执行2.js这说明CommonJS加载模块是同步进行的</p>
<ul>
<li>这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快； </li>
<li>但是在客户端的话情况就不会很乐观，这意味着后面的js代码无法继续正常执行，即使是一些简单的DOM操作</li>
</ul>
<p>所以在浏览器中我们通常不使用CommonJS规范，一般使用ES Module进行模块化开发</p>
<h2 id="ES-Module的特点"><a href="#ES-Module的特点" class="headerlink" title="ES Module的特点"></a>ES Module的特点</h2><p> ES Module模块采用export和import<strong>关键字</strong>来实现模块化：</p>
<ul>
<li>export负责将模块内的内容导出；</li>
<li>import负责从其他模块导入内容；</li>
</ul>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ol>
<li><p>采用<code>ES Module</code>将自动采用严格模式：use strict </p>
<p>如果你不熟悉严格模式可以简单看一下MDN上的解析： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</a></p>
</li>
<li><p>当你在浏览器中直接打开这段代码的时候，会发生跨域。</p>
</li>
</ol>
<p>这个问题在MDN上也有相应的解释：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules</a></p>
<p>大致意思就是： 当本地测试的时候，如果你通过本地加载Html 文件 (比如一个 file:// 路径的文件), 你将会遇到 CORS 错误，因为Javascript 模块安全性需要。 </p>
<p>所以你需要通过一个服务器来测试。</p>
<img src="/2020/11/26/Javascript中的模块化/13.png" title="This is an example image">

<figure class="image-box">
                <img src="C:\Users\lixiang17\AppData\Roaming\Typora\typora-user-images\image-20201120165255145.png" alt="image-20201120165255145" title="" class="">
                <p>image-20201120165255145</p>
            </figure>

<h4 id="export关键字"><a href="#export关键字" class="headerlink" title="export关键字"></a>export关键字</h4><p>export关键字将一个模块中的变量、函数、类等导出；</p>
<p> 我们希望将其他中内容全部导出，它可以有如下的方式：</p>
<ul>
<li>方式一：在语句声明的前面直接加上export关键字</li>
<li>方式二：将所有需要导出的标识符，放到export后面的 {}中 p 注意：这里的 {}里面不是ES6的对象字面量的增强写法，{}也不是表示一个对象的； 所以： export {name: name}，是错误的写法；</li>
<li>方式三：导出时给标识符起一个别名</li>
</ul>
<h4 id="import关键字"><a href="#import关键字" class="headerlink" title="import关键字"></a>import关键字</h4><p>import关键字负责从另外一个模块中导入内容</p>
<p>导入内容的方式也有多种：</p>
<ul>
<li>方式一：import {标识符列表} from '模块'； p 注意：这里的{}也不是一个对象，里面只是存放导入的标识符列表内容；</li>
<li>方式二：导入时给标识符起别名</li>
<li>方式三：通过 * 将模块功能放到一个模块功能对象（a module object）上</li>
</ul>
<img src="/2020/11/26/Javascript中的模块化/14.png" title="This is an example image">



<h4 id="default用法"><a href="#default用法" class="headerlink" title="default用法"></a>default用法</h4><p>前面我们学习的导出功能都是有名字的导出（named exports）： </p>
<ul>
<li>在导出export时指定了名字； </li>
<li>在导入import时需要知道具体的名字；</li>
</ul>
<p>还有一种导出叫做默认导出（default export）</p>
<ul>
<li>默认导出export时可以不需要指定名字； </li>
<li>在导入时不需要使用 {}，并且可以自己来指定名字； </li>
<li>它也方便我们和现有的CommonJS等规范相互操作；</li>
</ul>
<img src="/2020/11/26/Javascript中的模块化/15.png" title="This is an example image">

<p><strong>注意：在一个模块中，只能有一个默认导出（default export）；</strong></p>
<h4 id="Node对ES-Module的支持"><a href="#Node对ES-Module的支持" class="headerlink" title="Node对ES Module的支持"></a>Node对ES Module的支持</h4><p>在最新的Current版本中，支持es module我们需要进行如下操作：</p>
<ul>
<li>方式一：在package.json中配置 type: module</li>
<li>方式二：文件以 .mjs 结尾，表示使用的是ES Module； </li>
</ul>
<h4 id="ES-Module加载过程"><a href="#ES-Module加载过程" class="headerlink" title="ES Module加载过程"></a>ES Module加载过程</h4><p>ES Module加载js文件的过程是编译（解析）时加载的，并且是异步的</p>
<p>异步的意味着：JS引擎在遇到import时会去获取这个js文件，但是这个获取的过程是异步的，并不会阻塞主线程继续执行； </p>
<ul>
<li>也就是说设置了 type=module 的代码，相当于在script标签上也加上了 async 属性； </li>
<li>如果我们后面有普通的script标签以及对应的代码，那么ES Module对应的js文件和代码不会阻塞它们的执行</li>
</ul>
<img src="/2020/11/26/Javascript中的模块化/16.png" title="This is an example image">





















































































</script></p>]]></content>
      
        <categories>
            
            <category> 笔记 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Redux的工程化应用]]></title>
      <url>/2020/05/20/Redux%E7%9A%84%E5%B7%A5%E7%A8%8B%E5%8C%96%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><blockquote>
<p>是一个非常热门的状态管理工具</p>
</blockquote>
<h2 id="工程化的Redux目录结构"><a href="#工程化的Redux目录结构" class="headerlink" title="工程化的Redux目录结构"></a>工程化的Redux目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|-store</span><br><span class="line"></span><br><span class="line">    |-index.js  创建redux容器</span><br><span class="line"></span><br><span class="line">    |-action-types.js  宏管理行为标识</span><br><span class="line"></span><br><span class="line">    |-reducers</span><br><span class="line">        |-index.js 最终各个板块合并后的reducer</span><br><span class="line">        |-voteReducer.js  每个板块下的reducer</span><br><span class="line">        </span><br><span class="line">    |-actions  </span><br><span class="line">        voteActions.js</span><br><span class="line">        index.js</span><br></pre></td></tr></table></figure>

<h3 id="工程化操作"><a href="#工程化操作" class="headerlink" title="工程化操作"></a>工程化操作</h3><h4 id="首先：进行redux的安装"><a href="#首先：进行redux的安装" class="headerlink" title="首先：进行redux的安装"></a>首先：进行redux的安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i redux</span><br></pre></td></tr></table></figure>

<h4 id="进行store的初始化操作"><a href="#进行store的初始化操作" class="headerlink" title="进行store的初始化操作"></a>进行store的初始化操作</h4><img src="/2020/05/20/Redux的工程化应用/1.png" title="This is an example image">

<h4 id="创建单个模块的reducer函数"><a href="#创建单个模块的reducer函数" class="headerlink" title="创建单个模块的reducer函数"></a>创建单个模块的reducer函数</h4><img src="/2020/05/20/Redux的工程化应用/2.png" title="This is an example image">

<h4 id="创建action-types"><a href="#创建action-types" class="headerlink" title="创建action-types"></a>创建action-types</h4><img src="/2020/05/20/Redux的工程化应用/3.png" title="This is an example image">

<h4 id="整合reducer函数"><a href="#整合reducer函数" class="headerlink" title="整合reducer函数"></a>整合reducer函数</h4><img src="/2020/05/20/Redux的工程化应用/4.png" title="This is an example image">

<h4 id="创建单个模块的action"><a href="#创建单个模块的action" class="headerlink" title="创建单个模块的action"></a>创建单个模块的action</h4><img src="/2020/05/20/Redux的工程化应用/5.png" title="This is an example image">

<h4 id="整合action"><a href="#整合action" class="headerlink" title="整合action"></a>整合action</h4><img src="/2020/05/20/Redux的工程化应用/6.png" title="This is an example image">


<h4 id="以上是工程化初始化store的几个步骤"><a href="#以上是工程化初始化store的几个步骤" class="headerlink" title="以上是工程化初始化store的几个步骤"></a>以上是工程化初始化store的几个步骤</h4><h4 id="获取store中的值，以及提醒页面刷新的操作"><a href="#获取store中的值，以及提醒页面刷新的操作" class="headerlink" title="获取store中的值，以及提醒页面刷新的操作"></a>获取store中的值，以及提醒页面刷新的操作</h4><img src="/2020/05/20/Redux的工程化应用/7.png" title="This is an example image">

<h4 id="触发dispatch来修改action-type进行对store中的state进行操作"><a href="#触发dispatch来修改action-type进行对store中的state进行操作" class="headerlink" title="触发dispatch来修改action.type进行对store中的state进行操作"></a>触发dispatch来修改action.type进行对store中的state进行操作</h4><img src="/2020/05/20/Redux的工程化应用/8.png" title="This is an example image">]]></content>
      
        
        <tags>
            
            <tag> React框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅析React的渲染机制]]></title>
      <url>/2020/01/17/%E6%B5%85%E6%9E%90React%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h3 id="把JSX（虚拟DOM）变为真实的DOM的过程"><a href="#把JSX（虚拟DOM）变为真实的DOM的过程" class="headerlink" title="把JSX（虚拟DOM）变为真实的DOM的过程"></a>把JSX（虚拟DOM）变为真实的DOM的过程</h3><h4 id="主要分为以下三个步骤"><a href="#主要分为以下三个步骤" class="headerlink" title="主要分为以下三个步骤"></a>主要分为以下三个步骤</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.基于babel中的语法解析模块把jsx的语法转换为为React.createElement(...)结构</span><br><span class="line"></span><br><span class="line">2.执行React.createElement(【type】，【props】，【children】)，创建一个对象（也就是虚拟dom）</span><br><span class="line"></span><br><span class="line">3.ReactDOM.render（JSX语法最后生成的对象，容器，回调函数），基于render方法把生成</span><br><span class="line">的对象动态创建为DOM元素，插入到指定容器中。</span><br></pre></td></tr></table></figure>

<h3 id="JSX的渲染的实现"><a href="#JSX的渲染的实现" class="headerlink" title="JSX的渲染的实现"></a>JSX的渲染的实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先是模拟React.createElement的实现，其核心思想就是将传入的参数进行处理，返回一个新的对象（也就是我们常说的虚拟dom）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    obj.type = type;</span><br><span class="line"></span><br><span class="line">    obj.props = props || &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (props[<span class="string">'key'</span>]) &#123;</span><br><span class="line">        obj[<span class="string">'key'</span>] = props[<span class="string">'key'</span>];</span><br><span class="line">        obj[<span class="string">'props'</span>][<span class="string">'key'</span>] = <span class="literal">undefined</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj[<span class="string">'key'</span>] = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (props[<span class="string">'ref'</span>]) &#123;</span><br><span class="line">        </span><br><span class="line">        obj[<span class="string">'ref'</span>] = props[<span class="string">'ref'</span>];</span><br><span class="line">        <span class="built_in">console</span>.log(obj[<span class="string">'ref'</span>])</span><br><span class="line">        obj[<span class="string">'props'</span>][<span class="string">'ref'</span>] = <span class="literal">undefined</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj[<span class="string">'ref'</span>] = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (children.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        obj.props.children = children.length === <span class="number">1</span> ? children[<span class="number">0</span>] : children;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//render方法的核心思想就是将create方法返回的虚拟dom对象进行解析，渲染到页面上。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">jsxObj, root, callback</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> &#123; type, props &#125; = jsxObj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> element = <span class="built_in">document</span>.createElement(type);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!props.hasOwnProperty(key)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">'className'</span>) &#123;</span><br><span class="line"></span><br><span class="line">            element.className = props[<span class="string">'className'</span>];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">'style'</span>) &#123;</span><br><span class="line">            <span class="keyword">let</span> sty = props[<span class="string">'style'</span>]</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">let</span> attr <span class="keyword">in</span> sty) &#123;</span><br><span class="line"></span><br><span class="line">                element[<span class="string">'style'</span>][attr] = sty[attr]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key === <span class="string">'children'</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">let</span> children = props[<span class="string">'children'</span>];</span><br><span class="line"></span><br><span class="line">            children = <span class="built_in">Array</span>.isArray(children) ? children : [children];</span><br><span class="line">            children.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">typeof</span> item === <span class="string">'string'</span>) &#123;</span><br><span class="line">                    element.appendChild(<span class="built_in">document</span>.createTextNode(item))</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                render(item, element)</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(key===<span class="string">'ref'</span>)&#123;</span><br><span class="line">            element.setAttribute(<span class="string">'ref'</span>,jsxObj[<span class="string">'ref'</span>]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(key===<span class="string">'key'</span>)&#123;</span><br><span class="line">            element.setAttribute(<span class="string">'key'</span>,jsxObj[<span class="string">'key'</span>]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        element.setAttribute(key, props[key])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">root.appendChild(element);</span><br><span class="line">callback&amp;&amp;callback();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      
        
        <tags>
            
            <tag> React框架 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[大厂必备技能————webpack]]></title>
      <url>/2019/08/29/webpack%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="webpack-是什么？"><a href="#webpack-是什么？" class="headerlink" title="webpack 是什么？"></a>webpack 是什么？</h2><ul>
<li>官⽅方⽹网站:<a href="https://webpack.js.org/" target="_blank" rel="noopener">https://webpack.js.org/</a></li>
<li>中⽂文⽹网站:<a href="https://www.webpackjs.com/" target="_blank" rel="noopener">https://www.webpackjs.com/</a></li>
</ul>
<img src="/2019/08/29/webpack配置详解/webpack1.png" title="This is an example image">




<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>webpack</code> 是一个使用 <code>Node.js</code> 实现的一个模块化代码打包工具。所以，我们需要先安装 webpack，安装之前需要搭建好 <code>Node.js</code> 环境</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D webpack webpack-cli</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：不推荐全局安装</p>
</blockquote>
<p><code>webpack-cli</code> : 提供 webpack 命令、工具，类似 <code>create-react-app</code></p>
<p><code>webpack</code> : webpack 代码，类似 <code>react</code></p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/webpack</span><br><span class="line"></span><br><span class="line">// 查看版本</span><br><span class="line">./node_modules/.bin/webpack -v</span><br></pre></td></tr></table></figure>

<p>也可以编辑 <code>package.json</code> 的 <code>scripts</code> 来简化输入</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line">&#123;</span><br><span class="line">	...,</span><br><span class="line">	"scripts": &#123;</span><br><span class="line">		"start": "webpack"	// scripts 中可以定位到 ./node_modules/.bin/ 目录下</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>scripts</code> 中使用 <code>test</code>、<code>start</code>、<code>restart</code>、<code>stop</code> 命名的时候，可以在调用的时候省略 <code>run</code>，即直接 <code>npm start</code></p>
</blockquote>
<p>当然，还可以使用更加方便的方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack</span><br></pre></td></tr></table></figure>

<p>通过 <code>npx</code> 也可以帮助我们定位命令到 <code>./node_modules/.bin/</code> 目录下</p>
<blockquote>
<p>注：npm5.2+ 增加，如果没有，可以使用 npm i -g npx 来安装</p>
</blockquote>
<h2 id="打包模块"><a href="#打包模块" class="headerlink" title="打包模块"></a>打包模块</h2><p>打包之前，我们需要了解一个概念，入口文件</p>
<h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>入口文件就是我们项目中加载的第一个文件，比如上面的 <code>main.js</code> 文件，其它文件都是通过 <code>import</code> 等方式引入的，<code>webpack</code> 会从我们指定的入口文件开始分析所有需要依赖的文件，然后把打包成一个完整文件。</p>
<h2 id="打包配置"><a href="#打包配置" class="headerlink" title="打包配置"></a>打包配置</h2><p>虽然，我们可以直接通过命令的来打包，但是推荐创建一个 <code>webpack.config.js</code> 的配置文件来实现更方便和强大的功能。</p>
<p><code>webpack</code> 命令在运行的时候，默认会读取运行命令所在的目录下的 <code>webpack.config.js</code> 文件，通常我们会在项目的根目录下运行命令和创建配置文件。</p>
<p>我们也可以通过 <code>—config</code> 选项来指定配置文件路径：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --config ./configs/my_webpack.config.js</span><br></pre></td></tr></table></figure>

<p>通常情况下，我们的项目目录大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">-- /dist - 项目打包后存放目录</span><br><span class="line">-- /node_modules - 第三方模块</span><br><span class="line">-- /src</span><br><span class="line">------ css/</span><br><span class="line">------ images/</span><br><span class="line">------ js/</span><br><span class="line">------ index.js</span><br><span class="line">-- webpack.config.js</span><br><span class="line">-- package.json</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...	<span class="comment">//配置项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心配置"><a href="#核心配置" class="headerlink" title="核心配置"></a>核心配置</h2><h3 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h3><p>模式 : <code>&quot;production&quot; | &quot;development&quot; | &quot;none&quot;</code></p>
<!--cli-->

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>指定打包⼊口⽂文件，有三种不同的形式：<code>string | object | array</code></p>
<!--一对一：一个入口、一个打包文件-->

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--多对一：多个入口、一个打包文件-->

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: [</span><br><span class="line">    <span class="string">'./src/index1.js'</span>,</span><br><span class="line">    <span class="string">'./src/index2.js'</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--多对多：多个入口、多打包文件-->

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'index1'</span>: <span class="string">"./src/index1.js"</span>,</span><br><span class="line">    <span class="string">'index2'</span>: <span class="string">"./src/index2.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><p>打包后的文件位置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...,</span><br><span class="line">  output: &#123;</span><br><span class="line">  	path: path.resolve(__dirname, <span class="string">"dist"</span>),</span><br><span class="line">    filename: <span class="string">"bundle.js"</span>,</span><br><span class="line">		filename: <span class="string">"[name].js"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>可以指定一个固定的文件名称，如果是多入口多出口(<code>entry</code> 为对象)，则不能使用单文件出口，需要使用下面的方式</li>
<li>通过 <code>webpack</code> 内置的变量占位符：<code>[name]</code></li>
</ul>
<h2 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h2><p>在 <code>webpack</code> 中，有一个很重要的特性：模块不仅仅只是 <code>js</code> 的文件，<code>webpack</code> 可以把任意文件数据作为模块进行处理，包括：非 js 文本、css、图片等等</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> txt <span class="keyword">from</span> <span class="string">'./a.txt'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(txt);</span><br></pre></td></tr></table></figure>

<p>但是 <code>webpack</code> 默认情况下只能处理 <code>js</code> 模块，如果需要处理其它类型的模块，则需要使用它提供的一些其它功能</p>
<h3 id="执行简要流程"><a href="#执行简要流程" class="headerlink" title="执行简要流程"></a>执行简要流程</h3><img src="/2019/08/29/webpack配置详解/webpack2.png" title="This is an example image">



<ul>
<li>loaders<code>：</code>webpack<code>中灰常核心的内容之一，前面我们说的非 js 类型的模块处理就靠它了，不同类型的模块的解析就是依赖不同的</code>loader` 来实现的</li>
<li><code>plugins</code>：<code>webpack</code> 中另外一个核心的内容，它主要是扩展 <code>webpack</code> 本身的一些功能，它们会运行在各种模块解析完成以后的打包编译阶段，比如对解析后的模块文件进行压缩等</li>
</ul>
<h2 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h2><p><a href="https://webpack.js.org/loaders/" target="_blank" rel="noopener">https://webpack.js.org/loaders/</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">  	rules:[</span><br><span class="line">  		&#123;</span><br><span class="line">  			test:<span class="regexp">/\.xxx$/</span>,</span><br><span class="line">       	use:&#123;</span><br><span class="line">        	loader: <span class="string">'xxx-load'</span></span><br><span class="line">      	&#125;</span><br><span class="line">			&#125;</span><br><span class="line">  	]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>webpack</code> 碰到不识别的模块的时候，<code>webpack</code> 会在配置的 <code>module</code> 中进行该文件解析规则的查找</p>
<ul>
<li><code>rules</code> 就是我们为不同类型的文件定义的解析规则对应的 loader，它是一个数组</li>
<li>每一种类型规则通过 test 选项来定义，通过正则进行匹配，通常我们会通过正则的方式来匹配文件后缀类型</li>
<li><code>use</code> 针对匹配到文件类型，调用对应的 <code>loader</code> 进行处理</li>
</ul>
<p><strong>从一个简单的案例来了解 loader</strong></p>
<!--src/datas/data.txt-->

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是 txt 的内容</span><br></pre></td></tr></table></figure>

<!--src/datas/data.md-->

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 我是 md 的内容</span><br></pre></td></tr></table></figure>

<!--src/raw-loader.js-->

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> txtData <span class="keyword">from</span> <span class="string">'./datas/data.txt'</span>;</span><br><span class="line"><span class="keyword">import</span> mdData <span class="keyword">from</span> <span class="string">'./datas/data.md'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'txtData: '</span>, txtData);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'mdData: '</span>, mdData);</span><br></pre></td></tr></table></figure>

<p>默认情况下，webpack 会报错，因为 webpack 处理不了 txt 和 md 这样的非 js 的模块，但是我们可以通过专门来处理纯文本内容(不同的 loader 有不同的作用)</p>
<h3 id="raw-loader"><a href="#raw-loader" class="headerlink" title="raw-loader"></a>raw-loader</h3><p>在 webpack 中通过 import 方式导入文件内容，loader 并不是 webpack 内置的，所以首先要安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev raw-loader</span><br></pre></td></tr></table></figure>

<p>然后在 webpack.config.js 中进行配置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">      rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(txt|md)$/</span>,</span><br><span class="line">        use: <span class="string">'raw-loader'</span></span><br><span class="line">    	&#125;</span><br><span class="line">    ]</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a>file-loader</h3><p>把识别出的资源模块，移动到指定的输出⽬目录，并且返回这个资源在输出目录的地址(字符串)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  ...,</span><br><span class="line">	&#123;</span><br><span class="line">		test: <span class="regexp">/\.(png|jpe?g|gif)$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">      loader: <span class="string">"file-loader"</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        <span class="comment">// placeholder 占位符 [name] 源资源模块的名称</span></span><br><span class="line">        <span class="comment">// [ext] 源资源模块的后缀</span></span><br><span class="line">        name: <span class="string">"[name]_[hash].[ext]"</span>,</span><br><span class="line">        <span class="comment">//打包后的存放位置</span></span><br><span class="line">        outputPath: <span class="string">"./images"</span></span><br><span class="line">        <span class="comment">// 打包后文件的 url</span></span><br><span class="line">        publicPath: <span class="string">'./images'</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>占位符：<a href="https://webpack.js.org/loaders/file-loader#placeholders" target="_blank" rel="noopener">https://webpack.js.org/loaders/file-loader#placeholders</a></p>
</blockquote>
<h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a>url-loader</h3><p>可以处理理 <code>file-loader</code> 所有的事情，但是遇到图片格式的模块，可以选择性的把图片转成 <code>base64</code>  格式的字符串，并打包到 <code>js</code> 中，对⼩体积的图片⽐较合适，⼤图⽚不合适。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev url-loader</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  ...,</span><br><span class="line">	&#123;</span><br><span class="line">		test: <span class="regexp">/\.(png|jpe?g|gif)$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">      loader: <span class="string">"url-loader"</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        <span class="comment">// placeholder 占位符 [name] 源资源模块的名称</span></span><br><span class="line">        <span class="comment">// [ext] 源资源模块的后缀</span></span><br><span class="line">        name: <span class="string">"[name]_[hash].[ext]"</span>,</span><br><span class="line">        <span class="comment">//打包后的存放位置</span></span><br><span class="line">        outputPath: <span class="string">"./images"</span></span><br><span class="line">        <span class="comment">// 打包后文件的 url</span></span><br><span class="line">        publicPath: <span class="string">'./images'</span>,</span><br><span class="line">        <span class="comment">// 小于 100 字节转成 base64 格式</span></span><br><span class="line">        limit: <span class="number">100</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h3><p>分析 <code>css</code> 模块之间的关系，并合成⼀个 <code>css</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  ...,</span><br><span class="line">	&#123;</span><br><span class="line">		test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: &#123;</span><br><span class="line">      loader: <span class="string">"css-loader"</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">  			<span class="comment">// 启用/禁用 url() 处理</span></span><br><span class="line">  			url: <span class="literal">true</span>,</span><br><span class="line">  			<span class="comment">// 启用/禁用 @import 处理</span></span><br><span class="line">  			<span class="keyword">import</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 启用/禁用 Sourcemap</span></span><br><span class="line">        sourceMap: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h3><p>把 <code>css-loader</code> 生成的内容，用 <code>style</code> 标签挂载到⻚面的 <code>head</code> 中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev style-loader</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  ...,</span><br><span class="line">	&#123;</span><br><span class="line">		test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: [<span class="string">"style-loader"</span>, <span class="string">"css-loader"</span>]</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>同一个任务的 <code>loader</code> 可以同时挂载多个，处理顺序为：从右到左，也就是先通过 <code>css-loader</code> 处理，然后把处理后的 <code>css</code> 字符串交给 <code>style-loader</code> 进行处理</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rules: [</span><br><span class="line">  ...,</span><br><span class="line">	&#123;</span><br><span class="line">		test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: [</span><br><span class="line">  		&#123;</span><br><span class="line">  			loader: <span class="string">'style-loader'</span>,</span><br><span class="line">  			options: &#123;&#125;</span><br><span class="line">  		&#125;,</span><br><span class="line">      <span class="string">'css-loader'</span></span><br><span class="line">		]</span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="sass-loader"><a href="#sass-loader" class="headerlink" title="sass-loader"></a>sass-loader</h3><p>把 <code>sass</code> 语法转换成 <code>css</code> ，依赖 <code>node-sass</code> 模块</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev sass-loader node-sass</span><br></pre></td></tr></table></figure>

<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>扩展 <code>webpack</code> 本身的一些功能，它们会运行在各种模块解析完成以后的打包编译阶段，比如对解析后的模块文件进行压缩等</p>
<h3 id="HtmlWebpackPlugin"><a href="#HtmlWebpackPlugin" class="headerlink" title="HtmlWebpackPlugin"></a>HtmlWebpackPlugin</h3><p>在打包结束后，⾃动生成⼀个 <code>html</code> ⽂文件，并把打包生成的 js 模块引⼊到该 <code>html</code> 中</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev html-webpack-plugin</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">"html-webpack-plugin"</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	...</span><br><span class="line">  plugins: [</span><br><span class="line">     <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">       title: <span class="string">"My App"</span>,</span><br><span class="line">       filename: <span class="string">"app.html"</span>,</span><br><span class="line">       template: <span class="string">"./src/html/index.html"</span></span><br><span class="line">     &#125;) </span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>删除（清理）构建目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;CleanWebpackPlugin&#125; = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	...</span><br><span class="line">  plugins: [</span><br><span class="line">    ...,</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h3><p>提取 <code>CSS</code> 到一个单独的文件中</p>
<p>npm install –save-dev mini-css-extract-plugin</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">const MiniCssExtractPlugin = require(&apos;mini-css-extract-plugin&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">	...,</span><br><span class="line">  module: &#123;</span><br><span class="line">  	rules: [</span><br><span class="line">  		&#123;</span><br><span class="line">  			test: /\.s[ac]ss$/,</span><br><span class="line">  			use: [</span><br><span class="line">  				&#123;</span><br><span class="line">  					loader: MiniCssExtractPlugin.loader</span><br><span class="line">					&#125;,</span><br><span class="line">  				/*不能使用style-loader*/</span><br><span class="line">          &apos;css-loader&apos;,</span><br><span class="line">          &apos;sass-loader&apos;</span><br><span class="line">        ]</span><br><span class="line">			&#125;</span><br><span class="line">  	]</span><br><span class="line">	&#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    ...,</span><br><span class="line">    new MiniCssExtractPlugin(&#123;</span><br><span class="line">    	filename: &apos;[name].css&apos;</span><br><span class="line">    &#125;),</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sourceMap"><a href="#sourceMap" class="headerlink" title="sourceMap"></a>sourceMap</h3><p>我们实际运行在浏览器的代码是通过 <code>webpack</code> 打包合并甚至是压缩混淆过的代码，所生成的代码并不利于我们的调试和错误定位，我们可以通过 <code>sourceMap</code> 来解决这个问题，<code>sourceMap</code> 本质是一个记录了编译后代码与源代码的映射关系的文件，我们可以通过 <code>webpack</code> 的 <code>devtool</code> 选项来开启 <code>sourceMap</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'source-map'</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，编译后会为每一个编译文件生成一个对应的 <code>.map</code> 文件，同时在编译文件中添加一段对应的 <code>map</code> 文件引入代码</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//# sourceMappingURL=xx.js.map</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">/*# sourceMappingURL=xx.css.map*/</span></span><br></pre></td></tr></table></figure>

<p>同时，现代浏览器都能够识别 <code>sourceMap</code> 文件，如 <code>chrome</code>，会在 <code>Sources</code> 面板中显示根据编译文件与对应的 <code>map</code> 文件定位到源文件中，有利于我们的调试和错误定位</p>
<img src="/2019/08/29/webpack配置详解/webpack3.png" title="This is an example image">




<h2 id="WebpackDevServer"><a href="#WebpackDevServer" class="headerlink" title="WebpackDevServer"></a>WebpackDevServer</h2><p>每次的代码修改都需要重新编译打包，刷新浏览器，特别麻烦，我们可以通过安装 <code>webpackDevServer</code> 来改善这方面的体验</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev webpack-dev-server</span><br></pre></td></tr></table></figure>

<p>启动命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx webpack-dev-server</span><br></pre></td></tr></table></figure>

<p>或者，<code>package.json</code> 中添加 <code>scripts</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...,</span><br><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"server"</span>: <span class="string">"webpack-dev-server"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改 <code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">  	<span class="comment">// 生成的虚拟目录路径</span></span><br><span class="line">  	contentBase: <span class="string">"./dist"</span>,</span><br><span class="line">  	<span class="comment">// 自动开启浏览器</span></span><br><span class="line">  	open: <span class="literal">true</span>,</span><br><span class="line">  	<span class="comment">// 端口</span></span><br><span class="line">  	port: <span class="number">8081</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动服务以后，<code>webpack</code> 不在会把打包后的文件生成到硬盘真实目录中了，而是直接存在了内存中(同时虚拟了一个存放目录路径)，后期更新编译打包和访问速度大大提升</p>
<h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>当下前端的开发都是前后端分离开发的，前端开发过程中代码会运行在一个服务器环境下(如当前的 <code>WebpackDevServer</code>)，那么在处理一些后端请求的时候通常会出现跨域的问题。<code>WebpackDevServer</code> 内置了一个代理服务，通过内置代理就可以把我们的跨域请求转发目标服务器上(<code>WebpackDevServer</code> 内置的代理发送的请求属于后端 - <code>node</code>，不受同源策略限制)，具体如下：</p>
<!--后端代码，以 node 为例-->

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> KoaRouter = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> KoaRouter();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/api/info'</span>, <span class="keyword">async</span> ctx =&gt; &#123;</span><br><span class="line">    ctx.body = &#123;</span><br><span class="line">        username: <span class="string">'zMouse'</span>,</span><br><span class="line">        gender: <span class="string">'male'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.use( router.routes() );</span><br><span class="line">app.listen(<span class="number">8787</span>);</span><br></pre></td></tr></table></figure>

<!--前端代码-->

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  url: <span class="string">'http://localhost:8787/api/info'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'res'</span>,res.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>默认情况下，该代码运行以后会出现跨域请求错误，修改 <code>webpack</code> 配置</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">  	<span class="comment">// 生成的虚拟目录路径</span></span><br><span class="line">  	contentBase: <span class="string">"./dist"</span>,</span><br><span class="line">  	<span class="comment">// 自动开启浏览器</span></span><br><span class="line">  	open: <span class="literal">true</span>,</span><br><span class="line">  	<span class="comment">// 端口</span></span><br><span class="line">  	port: <span class="number">8081</span>,</span><br><span class="line">  	proxy: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">      	target: <span class="string">'http://localhost:8787'</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>proxy</code> 设置，当我们在当前 <code>WebpackDevServer</code> 环境下发送以 <code>/api</code> 开头的请求都会被转发到 <a href="http://localhost:8787" target="_blank" rel="noopener">http://localhost:8787</a> 目标服务器下</p>
<!--修改前端代码-->

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  <span class="comment">//url: 'http://locahost:8081/api/info',</span></span><br><span class="line">  url: <span class="string">'/api/info'</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'res'</span>,res.data);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意 <code>url</code> 地址要填写 <code>WebpackDevServer</code> 域，比如当前 <code>WebpackDevServer</code> 开启的是 <a href="http://localhost:8081，也就是我们当前前端代码运行的环境，那么请求的" target="_blank" rel="noopener">http://localhost:8081，也就是我们当前前端代码运行的环境，那么请求的</a> <code>url</code> 也必须发送到这里，当我们的请求满足了 <code>proxy</code> 中设置的 <code>/api</code> 开头，那么就会把请求转发到 <code>target</code> ，所以最后的实际请求是：<a href="http://lcoahost:8787/api/info" target="_blank" rel="noopener">http://lcoahost:8787/api/info</a></p>
<h2 id="Hot-Module-Replacement"><a href="#Hot-Module-Replacement" class="headerlink" title="Hot Module Replacement"></a>Hot Module Replacement</h2><p>在之前当代码有变化，我们使用的 <code>live reload</code>，也就是刷新整个页面，虽然这样为我们省掉了很多手动刷新页面的麻烦，但是这样即使只是修改了很小的内容，也会刷新整个页面，无法保持页面操作状态。<code>HMR</code> 随之就出现了，它的核心的局部（模块）更新，也就是不刷新页面，只更新变化的部分</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">  	<span class="comment">// 生成的虚拟目录路径</span></span><br><span class="line">  	contentBase: <span class="string">"./dist"</span>,</span><br><span class="line">  	<span class="comment">// 自动开启浏览器</span></span><br><span class="line">  	open: <span class="literal">true</span>,</span><br><span class="line">  	<span class="comment">// 端口</span></span><br><span class="line">  	port: <span class="number">8081</span>,</span><br><span class="line">  	<span class="comment">// 开启热更新</span></span><br><span class="line">  	hot:<span class="literal">true</span>,</span><br><span class="line">  	<span class="comment">// 即使 HMR 不生效，也不去刷新整个页面(选择开启)</span></span><br><span class="line">    hotOnly:<span class="literal">true</span>,</span><br><span class="line">  	proxy: &#123;</span><br><span class="line">      <span class="string">'/api'</span>: &#123;</span><br><span class="line">      	target: <span class="string">'http://localhost:8787'</span></span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>开启 <code>HMR</code> 以后，当代码发生变化，<code>webpack</code> 即会进行编译，并通过 <code>websocket</code> 通知客户端(浏览器)，我们需要监听处理来自 <code>webpack</code> 的通知，然后通过 <code>HMR</code> 提供的  <code>API</code> 来完成我们的局部更新逻辑</p>
<!--./fn1.js-->

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'start1!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<!--index.js-->

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fn1 <span class="keyword">from</span> <span class="string">'./fn1.js'</span>;</span><br><span class="line">box1.onclick = fn1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;<span class="comment">//如果开启 HMR</span></span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">'./fn1.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 更新逻辑</span></span><br><span class="line">      box1.onclick = fn1;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码就是 当 ./fn1.js 模块代码发生变化的时候，把最新的 fn1 函数绑定到 box1.onclick 上</p>
<p>从上面就可以看到，<code>HMR</code> 其实就是以模块为单位，当模块代码发生修改的时候，通知客户端进行对应的更新，而客户端则根据具体的模块来更新我们的页面逻辑(这些逻辑需要自己去实现)，好在当前一些常用的更新逻辑都有了现成的插件</p>
<p><strong>css热更新</strong></p>
<p>样式热更新比较简单，<code>style-loader</code> 中就已经集成实现了，我们只需要在 <code>use</code> 中使用就可以了</p>
<p><strong>react 热更新</strong></p>
<ul>
<li><a href="https://github.com/gaearon/react-hot-loader" target="_blank" rel="noopener">https://github.com/gaearon/react-hot-loader</a></li>
<li>react 脚手架中也有集成</li>
</ul>
<p><strong>vue 热更新</strong></p>
<ul>
<li><a href="https://github.com/vuejs/vue-loader" target="_blank" rel="noopener">https://github.com/vuejs/vue-loader</a></li>
<li>vue 脚手架中也有集成</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[你必须知道的ES6]]></title>
      <url>/2019/07/28/%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84ES6/</url>
      <content type="html"><![CDATA[<h2 id="ES6简介"><a href="#ES6简介" class="headerlink" title="ES6简介"></a>ES6简介</h2><p>也叫ECMACScript6.0</p>
<h3 id="浏览器兼容问题"><a href="#浏览器兼容问题" class="headerlink" title="浏览器兼容问题"></a>浏览器兼容问题</h3><p>babel 可以将高级代码转换成es5代码</p>
<h3 id="es6声明"><a href="#es6声明" class="headerlink" title="es6声明"></a>es6声明</h3><p>es6声明提供了新的声明方式代替了以前的var</p>
<p>var不支持局部作用域，会声明到全局作用域中只分两种：</p>
<ol>
<li>全局作用域</li>
<li>函数作用域</li>
</ol>
<h2 id="ES6新的声明方式let和const"><a href="#ES6新的声明方式let和const" class="headerlink" title="ES6新的声明方式let和const"></a>ES6新的声明方式let和const</h2><h4 id="let可以解决的问题"><a href="#let可以解决的问题" class="headerlink" title="let可以解决的问题"></a>let可以解决的问题</h4><p>1.解决作用域污染问题和局部作用域问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(let i=0;i&lt;num;i++)&#123;</span><br><span class="line"></span><br><span class="line">    let和&#123;&#125;配合可以产生一个作用域</span><br><span class="line"></span><br><span class="line">    let支持块级作用域声明的变量只会声明在当前作用域内</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i)</span><br><span class="line">此时会报错</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>两个变量不可以在一个作用域中重复声明</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a=1;</span><br><span class="line">let a=2;</span><br><span class="line">//此时会报错</span><br></pre></td></tr></table></figure>

<p>3.解决了预解析，变量提升 （const，和let都没有预解析这个功能）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);</span><br><span class="line">let a=1;      //此时会报错</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">暂存死区</span><br><span class="line">var a=1;</span><br><span class="line">&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    </span><br><span class="line">    let a=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>与let用法基本一致，但是通过const声明的变量不能被修改(不能被修改引用空间)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const a=2;</span><br><span class="line">a=1;</span><br><span class="line">//此时会报错</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const a=&#123;</span><br><span class="line">    aaa:&apos;bbb&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.aaa=&apos;ccc&apos;</span><br><span class="line">//此时是可以修改的</span><br></pre></td></tr></table></figure>

<h2 id="ES6解构赋值"><a href="#ES6解构赋值" class="headerlink" title="ES6解构赋值"></a>ES6解构赋值</h2><blockquote>
<p>按照一个数据值的结构，快速解析获取到其中的内容</p>
</blockquote>
<p>==一般项目中只针对数组和对象进行解构赋值==</p>
<h4 id="解构赋值在数组中的应用"><a href="#解构赋值在数组中的应用" class="headerlink" title="解构赋值在数组中的应用"></a>解构赋值在数组中的应用</h4><blockquote>
<p>解构：表示等号左右两边结构类似,数组的位置必须相同</p>
</blockquote>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arry=[1,2,3]</span><br><span class="line">let [A,B,C]=arry;</span><br><span class="line">console.log( , ,c)  //此时输出的值是3</span><br><span class="line">console.log(A,B,C)  //此时输出的值是1，2，3</span><br></pre></td></tr></table></figure>

<h4 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h4><p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123;length&#125;=[&apos;lx&apos;,9];</span><br><span class="line"></span><br><span class="line">获取数组的长度</span><br></pre></td></tr></table></figure>

<h4 id="用解构赋值来解决调换a和b的值"><a href="#用解构赋值来解决调换a和b的值" class="headerlink" title="用解构赋值来解决调换a和b的值"></a>用解构赋值来解决调换a和b的值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a=12</span><br><span class="line">    b=11</span><br><span class="line">[a,b]=[b,a]</span><br><span class="line"></span><br><span class="line">console.log(a,b)</span><br></pre></td></tr></table></figure>

<h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><blockquote>
<p>对象的解构赋值在默认情况下要求左侧变量名必须和右侧变量名的属性名保持一致才可以（在结构中直接输入属性名即可）</p>
</blockquote>
<blockquote>
<p>可以用：给解构的变量名起别名作为我们使用的变量</p>
</blockquote>
<h4 id="解构赋值案例"><a href="#解构赋值案例" class="headerlink" title="解构赋值案例"></a>解构赋值案例</h4><blockquote>
<p>在解构的时候，可以给变量设置默认值:如果当前变量对应的解构赋值中的这一项没有值，变量就是用默认值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var value=&#123;name:&apos;lx&apos;,age:9,score:[12,23,34,45]&#125;;</span><br><span class="line">let &#123;a,score:[b,...c]&#125;=value;</span><br><span class="line">console.log(a,b,c)</span><br></pre></td></tr></table></figure>

<h4 id="解构赋值在实战中的案例"><a href="#解构赋值在实战中的案例" class="headerlink" title="解构赋值在实战中的案例"></a>解构赋值在实战中的案例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn=function(&#123;name=&apos;hehe&apos;,age=0&#125;=&#123;&#125;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fn(&#123;name:&apos;lx&apos;,age:9&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="…在ES6中的应用"><a href="#…在ES6中的应用" class="headerlink" title="…在ES6中的应用"></a>…在ES6中的应用</h2><p>…在ES6语法中有三种含义</p>
<blockquote>
<p>剩余运算符</p>
</blockquote>
<blockquote>
<p>拓展运算符</p>
</blockquote>
<blockquote>
<p>展开运算符</p>
</blockquote>
<h3 id="当作剩余运算符使用的时候"><a href="#当作剩余运算符使用的时候" class="headerlink" title="当作剩余运算符使用的时候"></a>当作剩余运算符使用的时候</h3><p>==注意，做剩余运算符使用时必须处于解构的最后一位==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr=[12,13,45,56];</span><br><span class="line"></span><br><span class="line">let [a,...b]=ary;</span><br><span class="line"></span><br><span class="line">console.log(a,b)   //此时输出 12，[13，45，56]</span><br></pre></td></tr></table></figure>

<h3 id="当作展开运算符使用的时候"><a href="#当作展开运算符使用的时候" class="headerlink" title="当作展开运算符使用的时候"></a>当作展开运算符使用的时候</h3><blockquote>
<p>把数组（对象/类数组）中的每一项展开</p>
</blockquote>
<p>==注意：在对象操作中，…是浅拷贝（slice也是浅拷贝）==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//作为展开使用：</span><br><span class="line"></span><br><span class="line">let arr=[...[1,2,3,4],...[5,6,7,8]];</span><br><span class="line">console.log(arr)</span><br><span class="line">此时输出[1，2，3，4，5，6，7，8]</span><br><span class="line">----------------------------------------------------</span><br><span class="line">let arr=[12,23,34,45];</span><br><span class="line"></span><br><span class="line">let fn=function(a,b,c)&#123;</span><br><span class="line">    console.log(a,b,c)</span><br><span class="line">&#125;</span><br><span class="line">Math.max(...arr)  //此时输出45</span><br><span class="line"></span><br><span class="line">fn(...arr)  //此时输出12，23，34，45</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br><span class="line">//作为克隆对象使用</span><br><span class="line">let obj=&#123;name:&apos;lx&apos;&#125;;</span><br><span class="line">let obj2=&#123;age:9&#125;;</span><br><span class="line">let obj3=&#123;...obj,...obj2&#125;;</span><br><span class="line">console.log(obj3)</span><br><span class="line">----------------------------------------------</span><br><span class="line">//作为克隆数组使用 </span><br><span class="line">let ary=[12,23];</span><br><span class="line">let newAry=[...ary,100];</span><br></pre></td></tr></table></figure>

<h2 id="ES6中的模板字符串"><a href="#ES6中的模板字符串" class="headerlink" title="ES6中的模板字符串"></a>ES6中的模板字符串</h2><p>取消了原有的字符串拼接功能,是代码更加简单，而且改变了之前换行必须加+号的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var name=&apos;lx&apos;;</span><br><span class="line">     var age=19;</span><br><span class="line"></span><br><span class="line">     var str=`我叫$&#123;name&#125;,今年$&#123;age&#125;了！！！`;</span><br><span class="line">     console.log(str)</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p> 特点：没有arguments和this </p>
<h3 id="箭头函数获取arguments的值"><a href="#箭头函数获取arguments的值" class="headerlink" title="箭头函数获取arguments的值"></a>箭头函数获取arguments的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fn=(...arg)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    consoel.log(arg)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//输出arguments的值</span><br><span class="line"></span><br><span class="line">fn(1,2,3,4 )</span><br></pre></td></tr></table></figure>

<h4 id="解决this问题"><a href="#解决this问题" class="headerlink" title="解决this问题"></a>解决this问题</h4><ol>
<li>解决this的问题：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;</span><br><span class="line"></span><br><span class="line">           name: &apos;a&apos;,</span><br><span class="line"></span><br><span class="line">           b: function () &#123;</span><br><span class="line">               var that = this</span><br><span class="line">               setTimeout(function () &#123;</span><br><span class="line">                   console.log(that)</span><br><span class="line"></span><br><span class="line">               &#125;, 1000)</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       obj.b()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用bind解决this的问题</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;</span><br><span class="line"></span><br><span class="line">           name: &apos;a&apos;,</span><br><span class="line"></span><br><span class="line">           b: function () &#123;</span><br><span class="line">               </span><br><span class="line">               setTimeout(function () &#123;</span><br><span class="line">                   console.log(this)</span><br><span class="line"></span><br><span class="line">               &#125;.bind(this), 1000)</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       obj.b()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>用箭头函数解决问题</li>
</ol>
<p>因为箭头函数没有this属性和arguments属性，所以要向上一层作用域找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;</span><br><span class="line"></span><br><span class="line">           name: &apos;a&apos;,</span><br><span class="line"></span><br><span class="line">           b: function () &#123;</span><br><span class="line">               </span><br><span class="line">               setTimeout(()=&gt; &#123;</span><br><span class="line">                   console.log(this)</span><br><span class="line"></span><br><span class="line">               &#125;, 1000)</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       obj.b()</span><br></pre></td></tr></table></figure>

<p>==注意：let声明的变量不会被声明到全局上==</p>
<h4 id="函数可以赋予默认参数"><a href="#函数可以赋予默认参数" class="headerlink" title="// 函数可以赋予默认参数"></a>// 函数可以赋予默认参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let fn=(a=1,b=2)=&gt;&#123;</span><br><span class="line">    console.log(a,b);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<h3 id="es6中对象新增的方法"><a href="#es6中对象新增的方法" class="headerlink" title="es6中对象新增的方法"></a>es6中对象新增的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf(obj1,obj2)</span><br><span class="line"></span><br><span class="line">//表示将obj1继承自obj2</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(obj1)</span><br></pre></td></tr></table></figure>

<h3 id="es6中的class"><a href="#es6中的class" class="headerlink" title="es6中的class"></a>es6中的class</h3><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>class出来的这东西只能被new</li>
<li>类可以继承公有，私有和静态方法，，但是实例不可以</li>
<li>父类的构造函数中返回了一个引用类型，会把这个引用类型作为子类的this</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line"></span><br><span class="line">           constructor() &#123;</span><br><span class="line">               this.name = &apos;baba&apos;;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">           static drink() &#123;</span><br><span class="line">               console.log(&apos;我爱喝酒&apos;)</span><br><span class="line">           &#125;</span><br><span class="line">           eat() &#123;</span><br><span class="line">               console.log(&apos;我喜欢吃&apos;)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       class Child extends Parent &#123;</span><br><span class="line">           constructor() &#123;</span><br><span class="line">               super()</span><br><span class="line">               this.age = 9</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           smoke() &#123;</span><br><span class="line">               console.log(&apos;我爱吸烟&apos;)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       var c = new Child();</span><br><span class="line">       c.eat();</span><br><span class="line">       console.log(c.name)</span><br><span class="line">       Child.drink()</span><br></pre></td></tr></table></figure>

<h2 id="es6中的Map和Set"><a href="#es6中的Map和Set" class="headerlink" title="es6中的Map和Set"></a>es6中的Map和Set</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote>
<p>举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;];</span><br><span class="line">var scores = [95, 75, 85];</span><br></pre></td></tr></table></figure>

<p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);</span><br><span class="line">m.get(&apos;Michael&apos;); // 95</span><br></pre></td></tr></table></figure>

<h3 id="Map实例的创建"><a href="#Map实例的创建" class="headerlink" title="Map实例的创建"></a>Map实例的创建</h3><blockquote>
<p>初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map(); // 空Map</span><br><span class="line">m.set(&apos;Adam&apos;, 67); // 添加新的key-value</span><br><span class="line">m.set(&apos;Bob&apos;, 59);</span><br><span class="line">m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: true</span><br><span class="line">m.get(&apos;Adam&apos;); // 67</span><br><span class="line">m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos;</span><br><span class="line">m.get(&apos;Adam&apos;); // undefined</span><br></pre></td></tr></table></figure>

<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map();</span><br><span class="line">m.set(&apos;Adam&apos;, 67);</span><br><span class="line">m.set(&apos;Adam&apos;, 88);</span><br><span class="line">m.get(&apos;Adam&apos;); // 88</span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><blockquote>
<p>Set是一个构造函数，用于数组去重，是一组key的集合</p>
</blockquote>
<p>要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s1 = new Set(); // 空Set</span><br><span class="line">var s2 = new Set([1, 2, 3, 3]); // 含1, 2, 3</span><br></pre></td></tr></table></figure>

<p>重复元素在Set中自动被过滤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = new Set([1, 2, 3, 3, &apos;3&apos;]);</span><br><span class="line">s; // Set &#123;1, 2, 3, &quot;3&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>==!注意3和“3”是不同的元素==</p>
<h4 id="Set的添加操作"><a href="#Set的添加操作" class="headerlink" title="Set的添加操作"></a>Set的添加操作</h4><p>可以通过add(key)方法添加元素到实例Set中，元素可以重复添加，但是不会有效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.add(4);</span><br><span class="line">s; // Set &#123;1, 2, 3, 4&#125;</span><br><span class="line">s.add(4);</span><br><span class="line">s; // 仍然是 Set &#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>

<p>通过delete(key)的方法可以实现删除元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = new Set([1, 2, 3]);</span><br><span class="line">s; // Set &#123;1, 2, 3&#125;</span><br><span class="line">s.delete(3);</span><br><span class="line">s; // Set &#123;1, 2&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ES6新增的数据类型Symbol"><a href="#ES6新增的数据类型Symbol" class="headerlink" title="ES6新增的数据类型Symbol"></a>ES6新增的数据类型Symbol</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>ES6引入了一种新的原始数据类型Symbol(标志),表示独一无二的值，他是js的第七种数据类型<br>symbol值通过Symbol函数生成，也就是说，==对象的属性名==现在可以有两种类型，一种是原来就有的字符串，另一种是新增的symbol类型，凡是属性名属于symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
</blockquote>
<h4 id="symbol的创建"><a href="#symbol的创建" class="headerlink" title="symbol的创建"></a>symbol的创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s  = Symbol();</span><br><span class="line">console.log(typeof s)</span><br><span class="line">//&apos;symbol&apos;</span><br></pre></td></tr></table></figure>

<p>变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。</p>
<p>==Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。是一种类似于字符串的数据类型。==</p>
<h4 id="symbol的参数"><a href="#symbol的参数" class="headerlink" title="symbol的参数"></a>symbol的参数</h4><blockquote>
<p>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let s1 = Symbol(&apos;foo&apos;);</span><br><span class="line">let s2 = Symbol(&apos;bar&apos;);</span><br><span class="line">//s1和s2的本质都是symbol(),</span><br><span class="line"></span><br><span class="line">console.log(s1.toString()) // &quot;Symbol(foo)&quot;</span><br><span class="line">consoel.log(s2.toString()) // &quot;Symbol(bar)&quot;</span><br></pre></td></tr></table></figure>

<p>s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 没有参数的情况</span><br><span class="line">let s1 = Symbol();</span><br><span class="line">let s2 = Symbol();</span><br><span class="line"></span><br><span class="line">s1 === s2 // false</span><br><span class="line"></span><br><span class="line">// 有参数的情况</span><br><span class="line">let s1 = Symbol(&apos;foo&apos;);</span><br><span class="line">let s2 = Symbol(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">s1 === s2 // false</span><br></pre></td></tr></table></figure>

<h4 id="symbol值的特点"><a href="#symbol值的特点" class="headerlink" title="symbol值的特点"></a>symbol值的特点</h4><blockquote>
<p>Symbol 值不能与其他类型的值进行运算，会报错。Symbol 值可以显式转为字符串。另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let sym = Symbol(&apos;My symbol&apos;);</span><br><span class="line">String(sym) // &apos;Symbol(My symbol)&apos;</span><br><span class="line"></span><br><span class="line">Number(sym) // TypeError</span><br><span class="line">sym + 2 // TypeError</span><br><span class="line"></span><br><span class="line">let sym = Symbol();</span><br><span class="line">Boolean(sym) // true</span><br><span class="line">!sym  // false</span><br></pre></td></tr></table></figure>

<h4 id="作为属性名的symbol"><a href="#作为属性名的symbol" class="headerlink" title="作为属性名的symbol"></a>作为属性名的symbol</h4><blockquote>
<p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let mySymbol = Symbol();</span><br><span class="line"></span><br><span class="line">// 第一种写法</span><br><span class="line">let a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = &apos;Hello!&apos;;</span><br><span class="line"></span><br><span class="line">// 第二种写法</span><br><span class="line">let a = &#123;</span><br><span class="line">  [mySymbol]: &apos;Hello!&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 第三种写法</span><br><span class="line">let a = &#123;&#125;;</span><br><span class="line">Object.defineProperty(a, mySymbol, &#123; value: &apos;Hello!&apos; &#125;);</span><br><span class="line"></span><br><span class="line">// 以上写法都得到同样结果</span><br><span class="line">a[mySymbol] // &quot;Hello!&quot;</span><br></pre></td></tr></table></figure>

<p>Symbol 值作为对象属性名时，不能用点运算符。<br>在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<h4 id="symbol作为属性名的遍历"><a href="#symbol作为属性名的遍历" class="headerlink" title="symbol作为属性名的遍历"></a>symbol作为属性名的遍历</h4><p>symbol作为属性名，该属性不会出现在for …in,for…of 循环中,也不会被Object.keys()，Object.getOwnPrototypeNames()，JSON.stringify()返回，但是他也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getOwnPropertySymbols(obj))</span><br><span class="line">//输出的是所有的symbol类型的属性名（key）</span><br></pre></td></tr></table></figure>

<h3 id="ES7中的padStart-和padEnd"><a href="#ES7中的padStart-和padEnd" class="headerlink" title="ES7中的padStart()和padEnd()"></a>ES7中的padStart()和padEnd()</h3><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;x&apos;.padStart(5, &apos;ab&apos;) // &apos;ababx&apos;</span><br><span class="line">&apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;</span><br><span class="line">&apos;x&apos;.padEnd(5, &apos;ab&apos;) // &apos;xabab&apos;</span><br><span class="line">&apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos;</span><br></pre></td></tr></table></figure>

<p>padStart()和padStart()一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p>
<h3 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h3><p>主要用于给字符串补0</p>
]]></content>
      
        <categories>
            
            <category> ES6浅析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[超级详细的前端性能优化方案]]></title>
      <url>/2019/07/25/%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E7%9A%84%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
      <content type="html"><![CDATA[<h2 id="前端性能优化方案"><a href="#前端性能优化方案" class="headerlink" title="前端性能优化方案"></a>前端性能优化方案</h2><ol>
<li><p>在JS中尽量减少闭包的使用（原因：闭包会生成不释放的栈内存）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">A：循环给元素做事件绑定的时候，尽可能地把后期需要的信息（例如索引）</span><br><span class="line">，储存在元素的自定义属性上，而不是创建闭包存储</span><br><span class="line"></span><br><span class="line">B：可以在最外层形成一个闭包，把后续需要的公共信息进行存储</span><br><span class="line">，而不是每一个方法都创建闭包（例如：单例模式）</span><br><span class="line"></span><br><span class="line">C：尽可能的手动释放，不会占用内存（将对象的引用地址赋值为null）</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量合并css和js文件（把需要人引入的css合并为1个，js也合并为一个），原理：是在减少http请求次数尽可能地把合并后的代码进行压缩，减少http请求资源的大小 </p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">解决方案利用webpack这种自动化构建工具，</span><br><span class="line">可以帮我们实现代码的合并和压缩（工程化开发的一种）</span><br><span class="line"></span><br><span class="line">在移动端开发，（或者追求高性能的pc端开发）比如百度首页，</span><br><span class="line">如果css和js不是需要很多，我们可以选择把css和js编程内嵌式（也就是把代码直接写到html中）</span><br></pre></td></tr></table></figure>

<p>3.尽量使用字体图标或者 svg图标 ，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">来代替传统的png图片，因为字体图标等是矢量图（基于代码编写出来的）</span><br><span class="line">，放大不会变形，而且渲染速度快，相对比位图（png,jpg）要小一些</span><br></pre></td></tr></table></figure>

<p>4.减少对dom的操作，（主要是减少dom的重绘和回流（重排））</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A：关于重排的分离读写</span><br><span class="line">B：使用文档碎片或者字符串拼接做数据绑定（dom的动态创建）</span><br></pre></td></tr></table></figure>

<p>​<br>​<br>​<br>​    </p>
<p>5.在js中避免嵌套循环（‘这种循环会额外增加许多循环次数’）和‘死循环’（一旦遇到死循环，浏览器就卡壳了）</p>
<p>6.采用图片的懒加载（延迟加载）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目的就是为了减少页面‘第一次加载’过程中http的请求次数，让页面打开速度变快</span><br><span class="line"></span><br><span class="line">步骤：开始加载页面的时候，所有的真实图片都不去发送http请求加载。</span><br><span class="line">而是给一张占位的背景图，当页面加载完，并且图片在可视区域内我们再去做图片加载，</span><br></pre></td></tr></table></figure>

<p>7.利用浏览器和服务器端的缓存技术（304缓存），把一些不经常更新的静态资源文件做缓存处理，（例如：js，css，静态图片等都可以做缓存）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">原理是为了减少http的请求大小 ，让获取速度更快一点。</span><br></pre></td></tr></table></figure>

<p>8.尽可能使用事件委托（事件代理）来处理事件绑定的操作，减少dom的频繁操作 ，其中包括给每一个dom元素做事件绑定</p>
<p>9.尽量减少css表达式的使用（expression）</p>
<p>10.css解析器的解析规则是从右向左解析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.container .link a&#123;</span><br><span class="line">    </span><br><span class="line">    先找到所有的A，在筛选是在.link样式类中，最后在筛选.container中的，</span><br><span class="line">    操作起来是消耗性能的，我们在使用css选择器的时候尽可能减少对标签选择器的使用 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>11.做CDN加速（重量级加速，烧钱机器）</p>
<p>图示：</p>
<figure class="image-box">
                <img src="//yoursite.com/2019/07/25/超级详细的前端性能优化方案/Blog\source\_posts\超级详细的前端性能优化方案\1.png" alt title class>
                <p></p>
            </figure>











<p>12.css雪碧图技术（css sprite / css 图片精灵）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">把所有相对较小资源的图片汇总到一张大图上，后期我们只需要把大图加载下来，</span><br><span class="line">用背景定位的方式展示对应的小图即可</span><br><span class="line"></span><br><span class="line">.box&#123;</span><br><span class="line">    background:url(&apos;xxx.png&apos;)</span><br><span class="line">&#125;</span><br><span class="line">.box1&#123;</span><br><span class="line">    background-position:xx xx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.box2&#123;</span><br><span class="line">    background-position:xx xx</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;div class=&apos;bg box1&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>13.减少本地cookie的使用（最主要的就是减少本地cookie存储内容的大小）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为客户端操作cookie的时候。这些信息总是在客户端和服务器端的传来传去</span><br></pre></td></tr></table></figure>

<p>14.页面中的数据获取采用异步编程和延迟分批加载</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">使用异步获取数据，是为了降低hhttp通道的堵塞，</span><br><span class="line">不会因为数据没有请求回来耽误下面信息的渲染，</span><br><span class="line">提高页面的打开速度（我们可以这样处理，需要动态绑定数据的区域先隐藏，</span><br><span class="line">等数据返回并且绑定完成后在让其显示）</span><br><span class="line"></span><br><span class="line">延迟分批加载l类似于图片的懒加载，是为了减少第一次页面加载时候的http请求次数</span><br></pre></td></tr></table></figure>

<ol start="15">
<li>页面中出现音视频标签，</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">我们不让页面加载的时候就去加载这些资源（要不然加载速度会变慢）</span><br><span class="line">（方案：只需要设置preload：&quot;none&quot;即可）等到页面加载完成，音视频播放的时候，</span><br><span class="line">我们再去加载音视频资源</span><br></pre></td></tr></table></figure>

<p>16.在客户端和服务器端进行信息交互的时候，对于多项数据我们尽可能基于json格式进行传送（json格式数据处理方式，资源偏小—–》》》》》相对于xml格式的传输）</p>
<p>17.尽可能实现js的封装，（低耦合高内聚），较少页面中的冗余代码（减少http资源请求的大小）</p>
<p>18.css中设置定位后最好使用z-index改变层级让所有的盒子，不在相同的平面上，这样在后续的处理中，性能可以有一些的提高</p>
<p>19.在基于AJAX的get请求进行数据交互的时候，根据需求可以让其产生缓存（这个缓存不是304缓存），这样下一次从相同地址获取的数据是上一次缓存的数据（但是很少用，项目中一般会刻意清除这个缓存）</p>
<p>20.尽量减少对filter滤镜这个属性的使用(这个属性消耗性能较大)</p>
<p>21.在css导入的时候，尽量减少使用@import导入式，因为@import是同步操作，只有把这个对应的css导入，才会向下加载，而link是异步操作。</p>
<p>22.使用window.requestAnimationFrame（js中的帧动画）代替传统的定时器动画</p>
<p>23.减少递归的使用，避免死递归，避免由于递归导致的栈内存嵌套（建议使用尾递归）</p>
<p>24.避免使用iframe（不仅不好管理样式，而且相当于在a页面中加载了其他页面，消耗大）</p>
<p>25.利用h5中的localstorage本地存储或者是manifest离线缓存做一些信息的本地存储，下一次加载页面的时候直接从本地获取，减少http请求次数；</p>
<p>26.基于script标签调取js的时候，客户已经使用defer或者async来异步加载</p>
<p>27.</p>
<p>==额外技巧==</p>
<p>主要就分三条</p>
<ol>
<li>减少http的请求次数和请求大小</li>
<li>代码优化</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-&gt;有利于SEO</span><br><span class="line"></span><br><span class="line">-&gt;有利于代码维护</span><br><span class="line"></span><br><span class="line">-&gt;有利于性能消耗</span><br><span class="line"></span><br><span class="line">js优化的108条建议</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>DNS以及HTTP通讯方式的优化</li>
</ol>
<p>1.我们一般都把css放在body上，把js放在body下面（原因：先加载css再加载js，先加载css是保证渲染页面的过程中，元素是带着样式渲染的，而js一般都不是用来操作dom元素的，需要等到元素加载完再操作）</p>
<p>2.能用css搞定的绝不用js ，能用原生js搞定的绝不用插件，绝对不使用flash（除了音视频的低版本浏览器播放）<br>====》css处理动画的性能优于js，而且css中的transform变形还开了硬件加速</p>
<p>3.js中尽量减少对eval的使用，因为js合并压缩的时候，可能出现因为符号不完善，导致代码执行优先级错乱问题，eval处理起来消耗的性能也是偏大一点；</p>
<p>4.使用keep-alive实现客户端和服务器之间的长连接</p>
<p>5.尽量使用设计模式来管理我们的代码（单例，构造，promise，发布订阅），方便后期的升级和维护</p>
<p>6.开启服务器端的gzip（这个压缩可以减少请求资源的文件大小），其实客户端的图片等资源也是可以进行压缩的（但是对于24位的位图，压缩之后可能就变得模糊）</p>
<p>7.页面中不要出现无效的连接（利于seo优化），还有其他的技巧，提高关键字的曝光率，img需要提高曝光率，img需要加alt，设置meta标签，标签语义化。</p>
<p>8.避免使用with语句（非常消耗内存）</p>
]]></content>
      
        <categories>
            
            <category> 前端优化 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅析call，apply，bind]]></title>
      <url>/2019/07/25/%E6%B5%85%E6%9E%90call%EF%BC%8Capply%EF%BC%8Cbind/</url>
      <content type="html"><![CDATA[<h2 id="解析apply，call，bind"><a href="#解析apply，call，bind" class="headerlink" title="解析apply，call，bind"></a>解析apply，call，bind</h2><blockquote>
<p>整体都是用来改变this的指向的</p>
</blockquote>
<h3 id="三者来源"><a href="#三者来源" class="headerlink" title="三者来源"></a>三者来源</h3><blockquote>
<p>call，apply,bind来自于Function中的prototype中</p>
</blockquote>
<h3 id="call的用法"><a href="#call的用法" class="headerlink" title="call的用法"></a>call的用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn.call([this], 参数1，参数2......)</span><br><span class="line"></span><br><span class="line">//[this]的值是谁，fn的调用者就是谁</span><br></pre></td></tr></table></figure>

<blockquote>
<p>fn.call表示的是实例通过原型链的查找机制，找到Function.prototype上的call方法<br>fn.call()表示的是将找到的call方法执行</p>
</blockquote>
<p>当call方法执行的时候，内部处理了一些事情；</p>
<ul>
<li>首先把要操作函数中的this关键字变成calL()方法第一个传递的实参值</li>
<li>把call方法第二个以及第二个以后的实参获取到</li>
<li>把要操作的函数执行，并且把第二个以后传递进来的实参传给函数</li>
</ul>
<h4 id="一道关于call的面试题："><a href="#一道关于call的面试题：" class="headerlink" title="一道关于call的面试题："></a>一道关于call的面试题：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">window.name=&apos;lx&apos;;</span><br><span class="line"></span><br><span class="line">let fn=function()&#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj=&#123;</span><br><span class="line">    name:&apos;obj&apos;,</span><br><span class="line">    fn:fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let oo=&#123;name:&apos;oo&apos;&#125;</span><br><span class="line"></span><br><span class="line">fn();  // 此时输出的结果是lx</span><br><span class="line"></span><br><span class="line">obj.fn();  // 此时输出的是obj</span><br><span class="line"></span><br><span class="line">oo.fn(); // 此时会报错</span><br><span class="line"></span><br><span class="line">fn.call(oo); // 此时输出的结果是oo</span><br></pre></td></tr></table></figure>

<h4 id="call的细节"><a href="#call的细节" class="headerlink" title="call的细节"></a>call的细节</h4><ol>
<li>在非严格模式下，如果参数不传，或者第一个参数为null||undefined，this都指向undefined</li>
<li>在严格模式下，第一个参数是谁，this就指向谁（包括null和undefined），不传的话this是undefined</li>
<li>当一个函数被call调用，这个函数本身绝对不能是箭头函数（因为箭头函数本身没有this）！！！！</li>
</ol>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply和call基本一模一样，唯一却别在于传参方式</p>
<h4 id="apply的用法"><a href="#apply的用法" class="headerlink" title="apply的用法"></a>apply的用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn.apply([this],[ary[0],ary[1].ary[2]])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>apply把需要传递fn的参数放到一个数组中传递进去，虽然写的是一个数组，但是也相当于给fn一个一个传递的</p>
</blockquote>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><blockquote>
<p>语法方面和call是一样的，唯一的区别在于立即执行还是等待执行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn.call(obj,10,20) //改变fn中的this，并且把fn立即执行</span><br><span class="line"></span><br><span class="line">fn.bind(obj,10,20)  //改变fn中的this，，但是此时的fn没有执行</span><br></pre></td></tr></table></figure>

<h2 id="bind的应用"><a href="#bind的应用" class="headerlink" title="bind的应用"></a>bind的应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//如何一直输出同一个随机数</span><br><span class="line"></span><br><span class="line"> function showRandom()&#123;</span><br><span class="line">        this.number=parseInt(Math.random()*10+1);</span><br><span class="line">    &#125;</span><br><span class="line">    showRandom.prototype.show1=function()&#123;</span><br><span class="line">        window.setInterval(this.show2.bind(this),1000)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    showRandom.prototype.show2=function()&#123;</span><br><span class="line">        console.log(this.number)</span><br><span class="line">    &#125;</span><br><span class="line">    var sr=new showRandom();</span><br><span class="line">    sr.show1();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据上述代码call和apply都是改变this的指向，默认是调用完毕的；<br>而bind改变指向之后也仅仅是一个函数；</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[对前端‘事件’的一点理解]]></title>
      <url>/2019/07/10/%E5%AF%B9%E5%89%8D%E7%AB%AF%E2%80%98%E4%BA%8B%E4%BB%B6%E2%80%99%E7%9A%84%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="什么是事件"><a href="#什么是事件" class="headerlink" title="什么是事件"></a>什么是事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">事件就是一件事，或者一种行为（对于很多事件来说，很多事件都是天生自带的）</span><br></pre></td></tr></table></figure>

<h3 id="元素天自带的事件"><a href="#元素天自带的事件" class="headerlink" title="元素天自带的事件"></a>元素天自带的事件</h3><hr>
<h5 id="【鼠标事件】"><a href="#【鼠标事件】" class="headerlink" title="【鼠标事件】"></a>【鼠标事件】</h5><p>click：点击（抬起才算触发，PC端代表点击，移动端代表单击【使用click会有300ms的延迟】）</p>
<p>dblclick：双击</p>
<p>mouseover:鼠标经过（尽量不用）</p>
<p>mouseenter:鼠标进入</p>
<p>mouseout:鼠标移出（尽量不用）</p>
<p>mouseleave:鼠标离开</p>
<p>mousemove：鼠标移动</p>
<p>mousedown：鼠标按下（鼠标左右键都可以触发，click是按下抬起才算触发，并且是在down和up之后执行的）</p>
<p>mouseup：鼠标抬起</p>
<p>mousewheel：鼠标滚轮滚动</p>
<hr>
<h5 id="【键盘事件】"><a href="#【键盘事件】" class="headerlink" title="【键盘事件】"></a>【键盘事件】</h5><p>keydown：键盘按下</p>
<p>keyup：键盘抬起</p>
<p>keypress：和keydown相似。只不过keydown返回的是键盘码，keypress返回的是ascii码值</p>
<p>input事件：由于PC端有实体物理键盘，可以监听到键盘的按下和抬起，但是移动端是虚拟键盘，所以keydown和keyup在大部分手机上都没有，所以我们大多数统一使用input来替代他们</p>
<hr>
<h5 id="【表单元素常用的事件】"><a href="#【表单元素常用的事件】" class="headerlink" title="【表单元素常用的事件】"></a>【表单元素常用的事件】</h5><p>focus：获取焦点</p>
<p>blur：失去焦点</p>
<p>change：内容改变</p>
<hr>
<h5 id="【其他常用事件】"><a href="#【其他常用事件】" class="headerlink" title="【其他常用事件】"></a>【其他常用事件】</h5><p>load：加载完成</p>
<p>scroll：滚动条滚动事件</p>
<hr>
<p>（单手指操作）</p>
<p>#####【移动端手指事件】</p>
<p>touchstart：手指按下</p>
<p>touchmove：手指移动</p>
<p>touchend：手指离开</p>
<p>touchcancel：因意外情况导致手指操作取消</p>
<p>(多手指操作)</p>
<p>gesturestart:手指按下</p>
<p>gesturechange:手指改变</p>
<p>gestureend:手指离开</p>
<hr>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><h5 id="【DOM0级事件绑定】："><a href="#【DOM0级事件绑定】：" class="headerlink" title="【DOM0级事件绑定】："></a>【DOM0级事件绑定】：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【element】.onclick=function&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="【DOM2级事件绑定】"><a href="#【DOM2级事件绑定】" class="headerlink" title="【DOM2级事件绑定】"></a>【DOM2级事件绑定】</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[element].addEventListener(&apos;xxx&apos;,function()&#123;&#125;,true);</span><br><span class="line">[element].attachEvent(&apos;xxx&apos;,function()&#123;&#125;,true)    (IE6-8)</span><br></pre></td></tr></table></figure>

<h5 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h5><p>给当前元素的某个事件绑定方法，就是为了当元素触发某种行为的时候，能做点事情（也就是把绑定的方法执行），而且浏览器还给方法传递了一个实参信息值==》这个值就叫事件对象</p>
<h5 id="【moseEvent】"><a href="#【moseEvent】" class="headerlink" title="【moseEvent】"></a>【moseEvent】</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ele.onclick=function(e)&#123;</span><br><span class="line">     //定义一个形参值e来接收实参</span><br><span class="line">    console.log(e);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    //e.target:事件源（操作的是哪里的元素）</span><br><span class="line">    //e.clientX/e.clientY:当前鼠标触发点距离当前窗口左上角x/y的坐标</span><br><span class="line">    </span><br><span class="line">    //e.preventDefault();阻止默认行为</span><br><span class="line">    //e.stopPropagation();阻止事件的冒泡传播 </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="mouseover和mouseenter的区别"><a href="#mouseover和mouseenter的区别" class="headerlink" title="mouseover和mouseenter的区别"></a>mouseover和mouseenter的区别</h5><p>1.over属于滑过事件，从父元素进入到子元素，属于离开父元素，会触发父元素的out，出发子元素的over</p>
<p>enter属于进入，从父元素进入子元素，并不算离开父元素，不会触发父元素的leave，触发子元素的enter</p>
<p>2.enter和leave阻止了事件的冒泡传播，而over和out还存在冒泡传播的，所以对于父元素嵌套子元素这种情况的时候，我们一般使用enter和leave会更方便</p>
<h3 id="事件对象的兼容问题"><a href="#事件对象的兼容问题" class="headerlink" title="事件对象的兼容问题"></a>事件对象的兼容问题</h3><p>在IE6~8低版本浏览器中，浏览器执行绑定方法，并没有把事件对象传递进来，此时的e===undefined，需要通过基于window.event来获取(由于是是全局属性，鼠标每次操作都会把上次操作的值替换掉)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">//此时是IE6~8</span><br><span class="line"></span><br><span class="line">element.onclick=function(e)&#123;</span><br><span class="line"></span><br><span class="line">if(!e)&#123;</span><br><span class="line"></span><br><span class="line">    e=window.event</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    console.log(e.srcElement)；</span><br><span class="line"></span><br><span class="line">//此时是在获取事件源（标准浏览器中使用的是e.target）</span><br><span class="line"></span><br><span class="line">console.log(e.pageX);</span><br><span class="line"></span><br><span class="line">//此时输出的是undefined低版本中不存在pageX和pageY</span><br><span class="line"></span><br><span class="line">e.preventDefault=funtion()&#123;</span><br><span class="line">    e.returnValue=false; //低版本阻止冒泡行为</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">e.stopPropagation=function()&#123;</span><br><span class="line">    e.cancelBubble=true;//低版本阻止事件传播</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">e.stopPropagation(); //此时就可以像高版本一样执行冒泡</span><br><span class="line">e.preventDefault(); </span><br><span class="line">//此时就可以像高版本一样执行事件传播</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="兼容代码简写"><a href="#兼容代码简写" class="headerlink" title="兼容代码简写"></a>兼容代码简写</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">element.onclick=function()&#123;</span><br><span class="line">    </span><br><span class="line">    e=e||window.event;</span><br><span class="line">    </span><br><span class="line">    var target=e.target||e.srcElement;</span><br><span class="line">    e.preventDefault?e.preventDefault():e.returnValue=false; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## 事件的传播机制</span><br><span class="line"></span><br><span class="line">##### 事件传播机制流程图</span><br><span class="line">![](C:\Blog\source\_posts\对前端‘事件’的一点理解\1.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 注意</span><br><span class="line">不同浏览器对祖先元素的定义是不一样的</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### onclick和addEventListener的关于事件传播的区别</span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure>

<p>xxx.onclick=function(){</p>
<p>}</p>
<p>给元素绑定的方法，这些方法都是在<strong>冒泡阶段</strong>或<strong>目标阶段</strong>执行的</p>
<p>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></table></figure></p>
<p>xxx.addEventListener(‘xxx’,function(){},false)</p>
<p>第三个参数代表是否捕获，当参数为true的时候，允许该function在捕获阶段执行<br>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 事件委托（事件代理）</span><br><span class="line">##### 事件代理核心思路</span><br><span class="line">利用事件的冒泡传播机制，如果一个容器的后代元素中，很多元素的事件行为都需要做一些处理，此时我们不需要一个一个的绑定，我们只需给容器绑定一个方法即可，这样不管点击哪个后代元素，都会根据冒泡的传播机制，把容器的行为触发，把对应的方法执行，根据事件源，我们可以知道点击的是哪个元素，从而触发对应的事件</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">##### 事件代理流程图</span><br><span class="line">![](C:\Blog\source\_posts\对前端‘事件’的一点理解\2.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JQ中的事件绑定</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> js基础 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阿里经典面试题（内附详细解析哟）]]></title>
      <url>/2019/02/25/%E9%98%BF%E9%87%8C%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E5%86%85%E9%99%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%E5%93%9F%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="函数的角色"><a href="#函数的角色" class="headerlink" title="函数的角色"></a>函数的角色</h4><ol>
<li>普通函数</li>
</ol>
<p>—–》堆栈内存释放</p>
<p>—–》作用域链</p>
<ol start="2">
<li>类</li>
</ol>
<p>—–&gt;prototype :  原型</p>
<p>—-&gt;<strong>proto</strong>  :  原型链</p>
<ol start="3">
<li>普通对象</li>
</ol>
<p>——》和普通的函数没有区别–就是对键值对的的增删改查</p>
<p><strong>==&gt;       三种关系之间没有必然联系</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line">function Fn()&#123;</span><br><span class="line">    var m=10;</span><br><span class="line">    this.n=20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fn.protototype.aa=function()&#123;</span><br><span class="line">    consoleo.log(&apos;aa&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fn.bb=function()&#123;</span><br><span class="line">    console.log(&apos;bb&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​<br>=&gt;普通函数——-》this.n指的是window下的n，m指的是私有变量m</p>
<p>=&gt;构造函数执行的时候</p>
<p>var f=new Fn()</p>
<p>console.log(f.n)——m是Fn私有的变量和实例没有关系</p>
<p>f.n是实例的私有属性</p>
<p>f.aa实例通过prototype找到了Fn.prototype上的属性</p>
<p>f.bb是把Fn当作一个普通对象设置的属性而已，和实例没有半毛钱关系</p>
<p>=》普通对象：</p>
<p>Fn.bb是obj的属性</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>函数作为对象中使用的时候,只能对键值对进行增删改查，只能自己直接调用自己.出来的方法；不能调用prototype中的方法和属性</p>
<p>函数在作为构造函数使用的时候，实例可以调用prototype和this.出来的</p>
<p>函数作为普通函数的时候，只能使用自身的属性</p>
<h2 id="阿里巴巴关于函数的三种角色的面试题"><a href="#阿里巴巴关于函数的三种角色的面试题" class="headerlink" title="阿里巴巴关于函数的三种角色的面试题"></a>阿里巴巴关于函数的三种角色的面试题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;</span><br><span class="line">    </span><br><span class="line">    getName=function()&#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName=function()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.getName=function()&#123;</span><br><span class="line">    </span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getName=function()&#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getName()&#123;</span><br><span class="line">    console.log(5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题:</span><br><span class="line"></span><br><span class="line">1.Foo.getName();          </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">getName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foo().getName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new Foo.getName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new Foo().getName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new new Foo().getName();</span><br></pre></td></tr></table></figure>

<p>==2 ————————//此时把Foo当成一个对象，找到Foo的私有方法执行  </p>
<p>==4————————//由于变量提升，执行全局下的getName</p>
<p>==1————————//将getName重新赋值为1，然后return window继而调用全局下的getName（），此时的getName是1</p>
<p>==1————————//此时全局下的getName下的值为1</p>
<p>==2————————//因为无参数列表的new（）的优先级小于函数调用的优先级所以</p>
<p>==3————————//因为由参数列表的new的优先级大于函数调用的优先级，所以从左向右执行，因为是实例对象调用，所以先去构造函数身上找，当没有找到的时                候,再去prototype中去寻找</p>
<p>==3————————//先计算new Foo()，创建一个新的实例f,然后变成了  new f.getName()，然后执行f.getName最后再把执行后的结果new一下，其实就相当于把                            f.getName()当作一个类，然后再返回这个类的实例</p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
