<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[你必须知道的ES6]]></title>
      <url>/2019/07/28/%E4%BD%A0%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84ES6/</url>
      <content type="html"><![CDATA[<h2 id="ES6简介"><a href="#ES6简介" class="headerlink" title="ES6简介"></a>ES6简介</h2><p>也叫ECMACScript6.0</p>
<h3 id="浏览器兼容问题"><a href="#浏览器兼容问题" class="headerlink" title="浏览器兼容问题"></a>浏览器兼容问题</h3><p>babel 可以将高级代码转换成es5代码</p>
<h3 id="es6声明"><a href="#es6声明" class="headerlink" title="es6声明"></a>es6声明</h3><p>es6声明提供了新的声明方式代替了以前的var</p>
<p>var不支持局部作用域，会声明到全局作用域中只分两种：</p>
<ol>
<li>全局作用域</li>
<li>函数作用域</li>
</ol>
<h2 id="ES6新的声明方式let和const"><a href="#ES6新的声明方式let和const" class="headerlink" title="ES6新的声明方式let和const"></a>ES6新的声明方式let和const</h2><h4 id="let可以解决的问题"><a href="#let可以解决的问题" class="headerlink" title="let可以解决的问题"></a>let可以解决的问题</h4><p>1.解决作用域污染问题和局部作用域问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">for(let i=0;i&lt;num;i++)&#123;</span><br><span class="line"></span><br><span class="line">    let和&#123;&#125;配合可以产生一个作用域</span><br><span class="line"></span><br><span class="line">    let支持块级作用域声明的变量只会声明在当前作用域内</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(i)</span><br><span class="line">此时会报错</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>两个变量不可以在一个作用域中重复声明</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a=1;</span><br><span class="line">let a=2;</span><br><span class="line">//此时会报错</span><br></pre></td></tr></table></figure>

<p>3.解决了预解析，变量提升 （const，和let都没有预解析这个功能）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);</span><br><span class="line">let a=1;      //此时会报错</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">暂存死区</span><br><span class="line">var a=1;</span><br><span class="line">&#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    </span><br><span class="line">    let a=2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>与let用法基本一致，但是通过const声明的变量不能被修改(不能被修改引用空间)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const a=2;</span><br><span class="line">a=1;</span><br><span class="line">//此时会报错</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const a=&#123;</span><br><span class="line">    aaa:&apos;bbb&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.aaa=&apos;ccc&apos;</span><br><span class="line">//此时是可以修改的</span><br></pre></td></tr></table></figure>

<h2 id="ES6解构赋值"><a href="#ES6解构赋值" class="headerlink" title="ES6解构赋值"></a>ES6解构赋值</h2><blockquote>
<p>按照一个数据值的结构，快速解析获取到其中的内容</p>
</blockquote>
<p>==一般项目中只针对数组和对象进行解构赋值==</p>
<h4 id="解构赋值在数组中的应用"><a href="#解构赋值在数组中的应用" class="headerlink" title="解构赋值在数组中的应用"></a>解构赋值在数组中的应用</h4><blockquote>
<p>解构：表示等号左右两边结构类似,数组的位置必须相同</p>
</blockquote>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arry=[1,2,3]</span><br><span class="line">let [A,B,C]=arry;</span><br><span class="line">console.log( , ,c)  //此时输出的值是3</span><br><span class="line">console.log(A,B,C)  //此时输出的值是1，2，3</span><br></pre></td></tr></table></figure>

<h4 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h4><p>实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123;length&#125;=[&apos;lx&apos;,9];</span><br><span class="line"></span><br><span class="line">获取数组的长度</span><br></pre></td></tr></table></figure>

<h4 id="用解构赋值来解决调换a和b的值"><a href="#用解构赋值来解决调换a和b的值" class="headerlink" title="用解构赋值来解决调换a和b的值"></a>用解构赋值来解决调换a和b的值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a=12</span><br><span class="line">    b=11</span><br><span class="line">[a,b]=[b,a]</span><br><span class="line"></span><br><span class="line">console.log(a,b)</span><br></pre></td></tr></table></figure>

<h4 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h4><blockquote>
<p>对象的解构赋值在默认情况下要求左侧变量名必须和右侧变量名的属性名保持一致才可以（在结构中直接输入属性名即可）</p>
</blockquote>
<blockquote>
<p>可以用：给解构的变量名起别名作为我们使用的变量</p>
</blockquote>
<h4 id="解构赋值案例"><a href="#解构赋值案例" class="headerlink" title="解构赋值案例"></a>解构赋值案例</h4><blockquote>
<p>在解构的时候，可以给变量设置默认值:如果当前变量对应的解构赋值中的这一项没有值，变量就是用默认值</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var value=&#123;name:&apos;lx&apos;,age:9,score:[12,23,34,45]&#125;;</span><br><span class="line">let &#123;a,score:[b,...c]&#125;=value;</span><br><span class="line">console.log(a,b,c)</span><br></pre></td></tr></table></figure>

<h4 id="解构赋值在实战中的案例"><a href="#解构赋值在实战中的案例" class="headerlink" title="解构赋值在实战中的案例"></a>解构赋值在实战中的案例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn=function(&#123;name=&apos;hehe&apos;,age=0&#125;=&#123;&#125;)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fn(&#123;name:&apos;lx&apos;,age:9&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="…在ES6中的应用"><a href="#…在ES6中的应用" class="headerlink" title="…在ES6中的应用"></a>…在ES6中的应用</h2><p>…在ES6语法中有三种含义</p>
<blockquote>
<p>剩余运算符</p>
</blockquote>
<blockquote>
<p>拓展运算符</p>
</blockquote>
<blockquote>
<p>展开运算符</p>
</blockquote>
<h3 id="当作剩余运算符使用的时候"><a href="#当作剩余运算符使用的时候" class="headerlink" title="当作剩余运算符使用的时候"></a>当作剩余运算符使用的时候</h3><p>==注意，做剩余运算符使用时必须处于解构的最后一位==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr=[12,13,45,56];</span><br><span class="line"></span><br><span class="line">let [a,...b]=ary;</span><br><span class="line"></span><br><span class="line">console.log(a,b)   //此时输出 12，[13，45，56]</span><br></pre></td></tr></table></figure>

<h3 id="当作展开运算符使用的时候"><a href="#当作展开运算符使用的时候" class="headerlink" title="当作展开运算符使用的时候"></a>当作展开运算符使用的时候</h3><blockquote>
<p>把数组（对象/类数组）中的每一项展开</p>
</blockquote>
<p>==注意：在对象操作中，…是浅拷贝（slice也是浅拷贝）==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//作为展开使用：</span><br><span class="line"></span><br><span class="line">let arr=[...[1,2,3,4],...[5,6,7,8]];</span><br><span class="line">console.log(arr)</span><br><span class="line">此时输出[1，2，3，4，5，6，7，8]</span><br><span class="line">----------------------------------------------------</span><br><span class="line">let arr=[12,23,34,45];</span><br><span class="line"></span><br><span class="line">let fn=function(a,b,c)&#123;</span><br><span class="line">    console.log(a,b,c)</span><br><span class="line">&#125;</span><br><span class="line">Math.max(...arr)  //此时输出45</span><br><span class="line"></span><br><span class="line">fn(...arr)  //此时输出12，23，34，45</span><br><span class="line"></span><br><span class="line">---------------------------------------</span><br><span class="line">//作为克隆对象使用</span><br><span class="line">let obj=&#123;name:&apos;lx&apos;&#125;;</span><br><span class="line">let obj2=&#123;age:9&#125;;</span><br><span class="line">let obj3=&#123;...obj,...obj2&#125;;</span><br><span class="line">console.log(obj3)</span><br><span class="line">----------------------------------------------</span><br><span class="line">//作为克隆数组使用 </span><br><span class="line">let ary=[12,23];</span><br><span class="line">let newAry=[...ary,100];</span><br></pre></td></tr></table></figure>

<h2 id="ES6中的模板字符串"><a href="#ES6中的模板字符串" class="headerlink" title="ES6中的模板字符串"></a>ES6中的模板字符串</h2><p>取消了原有的字符串拼接功能,是代码更加简单，而且改变了之前换行必须加+号的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var name=&apos;lx&apos;;</span><br><span class="line">     var age=19;</span><br><span class="line"></span><br><span class="line">     var str=`我叫$&#123;name&#125;,今年$&#123;age&#125;了！！！`;</span><br><span class="line">     console.log(str)</span><br></pre></td></tr></table></figure>

<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p> 特点：没有arguments和this </p>
<h3 id="箭头函数获取arguments的值"><a href="#箭头函数获取arguments的值" class="headerlink" title="箭头函数获取arguments的值"></a>箭头函数获取arguments的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fn=(...arg)=&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    consoel.log(arg)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//输出arguments的值</span><br><span class="line"></span><br><span class="line">fn(1,2,3,4 )</span><br></pre></td></tr></table></figure>

<h4 id="解决this问题"><a href="#解决this问题" class="headerlink" title="解决this问题"></a>解决this问题</h4><ol>
<li>解决this的问题：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;</span><br><span class="line"></span><br><span class="line">           name: &apos;a&apos;,</span><br><span class="line"></span><br><span class="line">           b: function () &#123;</span><br><span class="line">               var that = this</span><br><span class="line">               setTimeout(function () &#123;</span><br><span class="line">                   console.log(that)</span><br><span class="line"></span><br><span class="line">               &#125;, 1000)</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       obj.b()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用bind解决this的问题</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;</span><br><span class="line"></span><br><span class="line">           name: &apos;a&apos;,</span><br><span class="line"></span><br><span class="line">           b: function () &#123;</span><br><span class="line">               </span><br><span class="line">               setTimeout(function () &#123;</span><br><span class="line">                   console.log(this)</span><br><span class="line"></span><br><span class="line">               &#125;.bind(this), 1000)</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       obj.b()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>用箭头函数解决问题</li>
</ol>
<p>因为箭头函数没有this属性和arguments属性，所以要向上一层作用域找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">obj = &#123;</span><br><span class="line"></span><br><span class="line">           name: &apos;a&apos;,</span><br><span class="line"></span><br><span class="line">           b: function () &#123;</span><br><span class="line">               </span><br><span class="line">               setTimeout(()=&gt; &#123;</span><br><span class="line">                   console.log(this)</span><br><span class="line"></span><br><span class="line">               &#125;, 1000)</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">       obj.b()</span><br></pre></td></tr></table></figure>

<p>==注意：let声明的变量不会被声明到全局上==</p>
<h4 id="函数可以赋予默认参数"><a href="#函数可以赋予默认参数" class="headerlink" title="// 函数可以赋予默认参数"></a>// 函数可以赋予默认参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let fn=(a=1,b=2)=&gt;&#123;</span><br><span class="line">    console.log(a,b);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>

<h3 id="es6中对象新增的方法"><a href="#es6中对象新增的方法" class="headerlink" title="es6中对象新增的方法"></a>es6中对象新增的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf(obj1,obj2)</span><br><span class="line"></span><br><span class="line">//表示将obj1继承自obj2</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(obj1)</span><br></pre></td></tr></table></figure>

<h3 id="es6中的class"><a href="#es6中的class" class="headerlink" title="es6中的class"></a>es6中的class</h3><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>class出来的这东西只能被new</li>
<li>类可以继承公有，私有和静态方法，，但是实例不可以</li>
<li>父类的构造函数中返回了一个引用类型，会把这个引用类型作为子类的this</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line"></span><br><span class="line">           constructor() &#123;</span><br><span class="line">               this.name = &apos;baba&apos;;</span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">           static drink() &#123;</span><br><span class="line">               console.log(&apos;我爱喝酒&apos;)</span><br><span class="line">           &#125;</span><br><span class="line">           eat() &#123;</span><br><span class="line">               console.log(&apos;我喜欢吃&apos;)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       class Child extends Parent &#123;</span><br><span class="line">           constructor() &#123;</span><br><span class="line">               super()</span><br><span class="line">               this.age = 9</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           smoke() &#123;</span><br><span class="line">               console.log(&apos;我爱吸烟&apos;)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       var c = new Child();</span><br><span class="line">       c.eat();</span><br><span class="line">       console.log(c.name)</span><br><span class="line">       Child.drink()</span><br></pre></td></tr></table></figure>

<h2 id="es6中的Map和Set"><a href="#es6中的Map和Set" class="headerlink" title="es6中的Map和Set"></a>es6中的Map和Set</h2><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><blockquote>
<p>举个例子，假设要根据同学的名字查找对应的成绩，如果用Array实现，需要两个Array：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var names = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;];</span><br><span class="line">var scores = [95, 75, 85];</span><br></pre></td></tr></table></figure>

<p>给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，Array越长，耗时越长。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>如果用Map实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用JavaScript写一个Map如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map([[&apos;Michael&apos;, 95], [&apos;Bob&apos;, 75], [&apos;Tracy&apos;, 85]]);</span><br><span class="line">m.get(&apos;Michael&apos;); // 95</span><br></pre></td></tr></table></figure>

<h3 id="Map实例的创建"><a href="#Map实例的创建" class="headerlink" title="Map实例的创建"></a>Map实例的创建</h3><blockquote>
<p>初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map(); // 空Map</span><br><span class="line">m.set(&apos;Adam&apos;, 67); // 添加新的key-value</span><br><span class="line">m.set(&apos;Bob&apos;, 59);</span><br><span class="line">m.has(&apos;Adam&apos;); // 是否存在key &apos;Adam&apos;: true</span><br><span class="line">m.get(&apos;Adam&apos;); // 67</span><br><span class="line">m.delete(&apos;Adam&apos;); // 删除key &apos;Adam&apos;</span><br><span class="line">m.get(&apos;Adam&apos;); // undefined</span><br></pre></td></tr></table></figure>

<p>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var m = new Map();</span><br><span class="line">m.set(&apos;Adam&apos;, 67);</span><br><span class="line">m.set(&apos;Adam&apos;, 88);</span><br><span class="line">m.get(&apos;Adam&apos;); // 88</span><br></pre></td></tr></table></figure>

<h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>Map和Set是ES6标准新增的数据类型，请根据浏览器的支持情况决定是否要使用。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><blockquote>
<p>Set是一个构造函数，用于数组去重，是一组key的集合</p>
</blockquote>
<p>要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s1 = new Set(); // 空Set</span><br><span class="line">var s2 = new Set([1, 2, 3, 3]); // 含1, 2, 3</span><br></pre></td></tr></table></figure>

<p>重复元素在Set中自动被过滤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s = new Set([1, 2, 3, 3, &apos;3&apos;]);</span><br><span class="line">s; // Set &#123;1, 2, 3, &quot;3&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>==!注意3和“3”是不同的元素==</p>
<h4 id="Set的添加操作"><a href="#Set的添加操作" class="headerlink" title="Set的添加操作"></a>Set的添加操作</h4><p>可以通过add(key)方法添加元素到实例Set中，元素可以重复添加，但是不会有效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s.add(4);</span><br><span class="line">s; // Set &#123;1, 2, 3, 4&#125;</span><br><span class="line">s.add(4);</span><br><span class="line">s; // 仍然是 Set &#123;1, 2, 3, 4&#125;</span><br></pre></td></tr></table></figure>

<p>通过delete(key)的方法可以实现删除元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = new Set([1, 2, 3]);</span><br><span class="line">s; // Set &#123;1, 2, 3&#125;</span><br><span class="line">s.delete(3);</span><br><span class="line">s; // Set &#123;1, 2&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ES6新增的数据类型Symbol"><a href="#ES6新增的数据类型Symbol" class="headerlink" title="ES6新增的数据类型Symbol"></a>ES6新增的数据类型Symbol</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><blockquote>
<p>ES6引入了一种新的原始数据类型Symbol(标志),表示独一无二的值，他是js的第七种数据类型<br>symbol值通过Symbol函数生成，也就是说，==对象的属性名==现在可以有两种类型，一种是原来就有的字符串，另一种是新增的symbol类型，凡是属性名属于symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
</blockquote>
<h4 id="symbol的创建"><a href="#symbol的创建" class="headerlink" title="symbol的创建"></a>symbol的创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let s  = Symbol();</span><br><span class="line">console.log(typeof s)</span><br><span class="line">//&apos;symbol&apos;</span><br></pre></td></tr></table></figure>

<p>变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。</p>
<p>==Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。是一种类似于字符串的数据类型。==</p>
<h4 id="symbol的参数"><a href="#symbol的参数" class="headerlink" title="symbol的参数"></a>symbol的参数</h4><blockquote>
<p>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let s1 = Symbol(&apos;foo&apos;);</span><br><span class="line">let s2 = Symbol(&apos;bar&apos;);</span><br><span class="line">//s1和s2的本质都是symbol(),</span><br><span class="line"></span><br><span class="line">console.log(s1.toString()) // &quot;Symbol(foo)&quot;</span><br><span class="line">consoel.log(s2.toString()) // &quot;Symbol(bar)&quot;</span><br></pre></td></tr></table></figure>

<p>s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 没有参数的情况</span><br><span class="line">let s1 = Symbol();</span><br><span class="line">let s2 = Symbol();</span><br><span class="line"></span><br><span class="line">s1 === s2 // false</span><br><span class="line"></span><br><span class="line">// 有参数的情况</span><br><span class="line">let s1 = Symbol(&apos;foo&apos;);</span><br><span class="line">let s2 = Symbol(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">s1 === s2 // false</span><br></pre></td></tr></table></figure>

<h4 id="symbol值的特点"><a href="#symbol值的特点" class="headerlink" title="symbol值的特点"></a>symbol值的特点</h4><blockquote>
<p>Symbol 值不能与其他类型的值进行运算，会报错。Symbol 值可以显式转为字符串。另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let sym = Symbol(&apos;My symbol&apos;);</span><br><span class="line">String(sym) // &apos;Symbol(My symbol)&apos;</span><br><span class="line"></span><br><span class="line">Number(sym) // TypeError</span><br><span class="line">sym + 2 // TypeError</span><br><span class="line"></span><br><span class="line">let sym = Symbol();</span><br><span class="line">Boolean(sym) // true</span><br><span class="line">!sym  // false</span><br></pre></td></tr></table></figure>

<h4 id="作为属性名的symbol"><a href="#作为属性名的symbol" class="headerlink" title="作为属性名的symbol"></a>作为属性名的symbol</h4><blockquote>
<p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let mySymbol = Symbol();</span><br><span class="line"></span><br><span class="line">// 第一种写法</span><br><span class="line">let a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = &apos;Hello!&apos;;</span><br><span class="line"></span><br><span class="line">// 第二种写法</span><br><span class="line">let a = &#123;</span><br><span class="line">  [mySymbol]: &apos;Hello!&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 第三种写法</span><br><span class="line">let a = &#123;&#125;;</span><br><span class="line">Object.defineProperty(a, mySymbol, &#123; value: &apos;Hello!&apos; &#125;);</span><br><span class="line"></span><br><span class="line">// 以上写法都得到同样结果</span><br><span class="line">a[mySymbol] // &quot;Hello!&quot;</span><br></pre></td></tr></table></figure>

<p>Symbol 值作为对象属性名时，不能用点运算符。<br>在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<h4 id="symbol作为属性名的遍历"><a href="#symbol作为属性名的遍历" class="headerlink" title="symbol作为属性名的遍历"></a>symbol作为属性名的遍历</h4><p>symbol作为属性名，该属性不会出现在for …in,for…of 循环中,也不会被Object.keys()，Object.getOwnPrototypeNames()，JSON.stringify()返回，但是他也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getOwnPropertySymbols(obj))</span><br><span class="line">//输出的是所有的symbol类型的属性名（key）</span><br></pre></td></tr></table></figure>

<h3 id="ES7中的padStart-和padEnd"><a href="#ES7中的padStart-和padEnd" class="headerlink" title="ES7中的padStart()和padEnd()"></a>ES7中的padStart()和padEnd()</h3><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&apos;x&apos;.padStart(5, &apos;ab&apos;) // &apos;ababx&apos;</span><br><span class="line">&apos;x&apos;.padStart(4, &apos;ab&apos;) // &apos;abax&apos;</span><br><span class="line">&apos;x&apos;.padEnd(5, &apos;ab&apos;) // &apos;xabab&apos;</span><br><span class="line">&apos;x&apos;.padEnd(4, &apos;ab&apos;) // &apos;xaba&apos;</span><br></pre></td></tr></table></figure>

<p>padStart()和padStart()一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p>
<h3 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h3><p>主要用于给字符串补0</p>
]]></content>
      
        <categories>
            
            <category> ES6浅析 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[超级详细的前端性能优化方案]]></title>
      <url>/2019/07/25/%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86%E7%9A%84%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88/</url>
      <content type="html"></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[浅析call，apply，bind]]></title>
      <url>/2019/07/25/%E6%B5%85%E6%9E%90call%EF%BC%8Capply%EF%BC%8Cbind/</url>
      <content type="html"><![CDATA[<h2 id="解析apply，call，bind"><a href="#解析apply，call，bind" class="headerlink" title="解析apply，call，bind"></a>解析apply，call，bind</h2><blockquote>
<p>整体都是用来改变this的指向的</p>
</blockquote>
<h3 id="三者来源"><a href="#三者来源" class="headerlink" title="三者来源"></a>三者来源</h3><blockquote>
<p>call，apply,bind来自于Function中的prototype中</p>
</blockquote>
<h3 id="call的用法"><a href="#call的用法" class="headerlink" title="call的用法"></a>call的用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn.call([this], 参数1，参数2......)</span><br><span class="line"></span><br><span class="line">//[this]的值是谁，fn的调用者就是谁</span><br></pre></td></tr></table></figure>

<blockquote>
<p>fn.call表示的是实例通过原型链的查找机制，找到Function.prototype上的call方法<br>fn.call()表示的是将找到的call方法执行</p>
</blockquote>
<p>当call方法执行的时候，内部处理了一些事情；</p>
<ul>
<li>首先把要操作函数中的this关键字变成calL()方法第一个传递的实参值</li>
<li>把call方法第二个以及第二个以后的实参获取到</li>
<li>把要操作的函数执行，并且把第二个以后传递进来的实参传给函数</li>
</ul>
<h4 id="一道关于call的面试题："><a href="#一道关于call的面试题：" class="headerlink" title="一道关于call的面试题："></a>一道关于call的面试题：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">window.name=&apos;lx&apos;;</span><br><span class="line"></span><br><span class="line">let fn=function()&#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let obj=&#123;</span><br><span class="line">    name:&apos;obj&apos;,</span><br><span class="line">    fn:fn</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let oo=&#123;name:&apos;oo&apos;&#125;</span><br><span class="line"></span><br><span class="line">fn();  // 此时输出的结果是lx</span><br><span class="line"></span><br><span class="line">obj.fn();  // 此时输出的是obj</span><br><span class="line"></span><br><span class="line">oo.fn(); // 此时会报错</span><br><span class="line"></span><br><span class="line">fn.call(oo); // 此时输出的结果是oo</span><br></pre></td></tr></table></figure>

<h4 id="call的细节"><a href="#call的细节" class="headerlink" title="call的细节"></a>call的细节</h4><ol>
<li>在非严格模式下，如果参数不传，或者第一个参数为null||undefined，this都指向undefined</li>
<li>在严格模式下，第一个参数是谁，this就指向谁（包括null和undefined），不传的话this是undefined</li>
<li>当一个函数被call调用，这个函数本身绝对不能是箭头函数（因为箭头函数本身没有this）！！！！</li>
</ol>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply和call基本一模一样，唯一却别在于传参方式</p>
<h4 id="apply的用法"><a href="#apply的用法" class="headerlink" title="apply的用法"></a>apply的用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn.apply([this],[ary[0],ary[1].ary[2]])</span><br></pre></td></tr></table></figure>

<blockquote>
<p>apply把需要传递fn的参数放到一个数组中传递进去，虽然写的是一个数组，但是也相当于给fn一个一个传递的</p>
</blockquote>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><blockquote>
<p>语法方面和call是一样的，唯一的区别在于立即执行还是等待执行</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn.call(obj,10,20) //改变fn中的this，并且把fn立即执行</span><br><span class="line"></span><br><span class="line">fn.bind(obj,10,20)  //改变fn中的this，，但是此时的fn没有执行</span><br></pre></td></tr></table></figure>

<h2 id="bind的应用"><a href="#bind的应用" class="headerlink" title="bind的应用"></a>bind的应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//如何一直输出同一个随机数</span><br><span class="line"></span><br><span class="line"> function showRandom()&#123;</span><br><span class="line">        this.number=parseInt(Math.random()*10+1);</span><br><span class="line">    &#125;</span><br><span class="line">    showRandom.prototype.show1=function()&#123;</span><br><span class="line">        window.setInterval(this.show2.bind(this),1000)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    showRandom.prototype.show2=function()&#123;</span><br><span class="line">        console.log(this.number)</span><br><span class="line">    &#125;</span><br><span class="line">    var sr=new showRandom();</span><br><span class="line">    sr.show1();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>根据上述代码call和apply都是改变this的指向，默认是调用完毕的；<br>而bind改变指向之后也仅仅是一个函数；</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 面试 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[嗨~~~~~闭包了解一下]]></title>
      <url>/2019/04/05/%E5%97%A8-%E9%97%AD%E5%8C%85%E4%BA%86%E8%A7%A3%E4%B8%80%E4%B8%8B/</url>
      <content type="html"><![CDATA[<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包的概念："><a href="#闭包的概念：" class="headerlink" title="闭包的概念："></a>闭包的概念：</h2><p><strong>当前私有栈内存中的某个东西（变量）正被此栈内存以外的的栈占用着，此时形成了闭包</strong></p>
<h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><blockquote>
<p>闭包就是形成了一个不销毁的私有作用域（私有栈内存）就是闭包</p>
</blockquote>
<h4 id="闭包的两种常见模型"><a href="#闭包的两种常见模型" class="headerlink" title="闭包的两种常见模型"></a>闭包的两种常见模型</h4><p><strong>闭包：柯理化函数</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">    return function ()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f=fn()</span><br></pre></td></tr></table></figure>

<p><strong>闭包：惰性函数</strong> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var utils=(function()&#123;</span><br><span class="line"></span><br><span class="line">return &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;)()</span><br><span class="line">此时util占用了return  所以自调用函数不能被销毁</span><br></pre></td></tr></table></figure>

<h2 id="闭包的作用："><a href="#闭包的作用：" class="headerlink" title="闭包的作用："></a>闭包的作用：</h2><p>1.缓存数据，形成不销毁的栈内存，把一些值保存下来，方便后面的调取和使用，延长作用域链</p>
<p>2.闭包具有保护作用，保护内部私有变量不受外界干扰</p>
<h2 id="闭包在真实项目中的应用"><a href="#闭包在真实项目中的应用" class="headerlink" title="闭包在真实项目中的应用"></a>闭包在真实项目中的应用</h2><p><strong>真实项目中为了保护js的性能（堆栈性能优化），应该尽量减少闭包的使用（不销毁的堆栈内存会消耗性能的）</strong></p>
<h6 id="闭包在保护方面的应用："><a href="#闭包在保护方面的应用：" class="headerlink" title="闭包在保护方面的应用："></a>闭包在保护方面的应用：</h6><blockquote>
<p>在团队协作开发的时候，应尽可能减少全局变量的使用，以防止相互之间的冲突&gt;&gt;（‘全局<br>变量污染’），此时我们完全可以把自己这部分内容封装到一个闭包中，让全局变&gt;量转换为私有变量<br>不仅如此，我们封装类库，和程序的时候都会放到闭包中保护起来，防止和用户的程序冲突</p>
</blockquote>
<h6 id="闭包在保存方面的使用"><a href="#闭包在保存方面的使用" class="headerlink" title="闭包在保存方面的使用"></a>闭包在保存方面的使用</h6><blockquote>
</blockquote>
<h2 id="闭包的应用："><a href="#闭包的应用：" class="headerlink" title="闭包的应用："></a>闭包的应用：</h2><p>//函数模式的闭包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function fn()&#123;</span><br><span class="line">    var num=10;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(num)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f1=fn();</span><br><span class="line">var result=f1();</span><br><span class="line">console.log(result)</span><br><span class="line">此时的result等于10完成了对num的缓存；</span><br></pre></td></tr></table></figure>

<p>//对象模式的闭包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f1()&#123;</span><br><span class="line">    var num=10;</span><br><span class="line">    return &#123;age:num&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">var obj=f1();</span><br><span class="line">console.log(obj.age)</span><br><span class="line">此时完成了对象模式中对num的缓存</span><br></pre></td></tr></table></figure>

<p>//关于闭包的两个小案例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">function f1()&#123;</span><br><span class="line">    var num=10;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        num++;</span><br><span class="line">        return num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f=f1();</span><br><span class="line">console.log(f())</span><br><span class="line">console.log(f())</span><br><span class="line">console.log(f())</span><br><span class="line">num的值分别等于11，12，13</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2.</span><br><span class="line">function f2()&#123;</span><br><span class="line">    var random=Math.random()*10+1;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        return random</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var f=f2();</span><br><span class="line">f();</span><br><span class="line">f();</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>

<h4 id="总结：如果想缓存数据，就把数据放在外层数据和里层数据中间的位置，"><a href="#总结：如果想缓存数据，就把数据放在外层数据和里层数据中间的位置，" class="headerlink" title="总结：如果想缓存数据，就把数据放在外层数据和里层数据中间的位置，"></a>总结：如果想缓存数据，就把数据放在外层数据和里层数据中间的位置，</h4><h4 id="局部变量是在函数中，函数使用结束后，局部变量就会被自动释放"><a href="#局部变量是在函数中，函数使用结束后，局部变量就会被自动释放" class="headerlink" title="局部变量是在函数中，函数使用结束后，局部变量就会被自动释放"></a>局部变量是在函数中，函数使用结束后，局部变量就会被自动释放</h4><h4 id="闭包后，里面的局部变量的使用作用域链就会被延长"><a href="#闭包后，里面的局部变量的使用作用域链就会被延长" class="headerlink" title="闭包后，里面的局部变量的使用作用域链就会被延长"></a>闭包后，里面的局部变量的使用作用域链就会被延长</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var i=1;</span><br><span class="line">function fn(i)&#123;</span><br><span class="line">    return function (n)&#123;</span><br><span class="line">        console.log(n+(++i))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f=fn(2);    //此时的fn依赖于f。所以f被保存</span><br><span class="line">f(3); </span><br><span class="line">fn(5)(6);   //被即时释放</span><br><span class="line">fn(7)(8);</span><br><span class="line">f(4)</span><br></pre></td></tr></table></figure>

<h3 id="闭包的一个常见的面试题"><a href="#闭包的一个常见的面试题" class="headerlink" title="闭包的一个常见的面试题"></a>闭包的一个常见的面试题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr=document.getElementsByClassName(&apos;arr&apos;)</span><br><span class="line">    for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        arr[i].addEventListener(&apos;click&apos;,function()&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            console.log(i)       //i的结果全部为6</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>原因：当我们点击的时候，外界js代码已经执行完毕，由于作用域链向上查找的i，是for中的i，也是全局变量中的i，所以都是6</p>
<h5 id="用闭包解决上面这个问题："><a href="#用闭包解决上面这个问题：" class="headerlink" title="用闭包解决上面这个问题："></a>用闭包解决上面这个问题：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr=document.getElementsByClassName(&apos;arr&apos;)</span><br><span class="line">    for(var i=0;i&lt;arr.length;i++)&#123;</span><br><span class="line">        arr[i].addEventListener(&apos;click&apos;,(function(n)&#123;</span><br><span class="line"></span><br><span class="line">            n=i</span><br><span class="line">            return function()&#123;</span><br><span class="line">                console.log(n)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i)))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将其改写成闭包的形式，缓存数据，用自调用函数的形式返回一个函数</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 闭包 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数组的内置方法你都记住了么]]></title>
      <url>/2019/03/25/%E6%95%B0%E7%BB%84%E7%9A%84%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E4%BD%A0%E9%83%BD%E8%AE%B0%E4%BD%8F%E4%BA%86%E4%B9%88/</url>
      <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="会改变原数组的方法"><a href="#会改变原数组的方法" class="headerlink" title="会改变原数组的方法"></a>会改变原数组的方法</h3><p>1.pop();<br>2.push();<br>3.shift();<br>4.unshift();<br>5.reverse();<br>6.sort()；<br>7.splice（）</p>
<h3 id="不会改变原数组的方法"><a href="#不会改变原数组的方法" class="headerlink" title="不会改变原数组的方法"></a>不会改变原数组的方法</h3><p>其余的都不会改变原数组</p>
<h4 id="创建数组的方式"><a href="#创建数组的方式" class="headerlink" title="创建数组的方式"></a>创建数组的方式</h4><p>//构造函数的方式</p>
<ol>
<li>var arr=new Array();<br>//字面量的方式</li>
<li>var arr1=[]</li>
</ol>
<h4 id="判断对象是不是数组类型：两种"><a href="#判断对象是不是数组类型：两种" class="headerlink" title="判断对象是不是数组类型：两种"></a>判断对象是不是数组类型：两种</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.instanceof</span><br><span class="line"></span><br><span class="line">var obj=&#123;&#125;;</span><br><span class="line">console.log(obj instanceof Array)   //false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//2.使用数组的</span><br><span class="line"></span><br><span class="line">console.log(Array.isArray(obj))</span><br><span class="line">//判断是否是数组</span><br></pre></td></tr></table></figure>

<h2 id="Array方法"><a href="#Array方法" class="headerlink" title="Array方法"></a>Array方法</h2><h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p>将两个数组连接起来，不会改变原有数组，只是返回了一个新的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr=[1,2,3,4]</span><br><span class="line">   let arr2=[5,6,7,8]</span><br><span class="line">   var arr3=arr.concat(arr2);</span><br><span class="line">   console.log(arr3)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>arr.push(值)</li>
</ol>
<p>把值追加到数组的最后一位，会改变原数组，返回值就是这个新的数组的<strong>长度</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr=[1,2,3,4]</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">       var arr1=arr.push(5);</span><br><span class="line">       console.log(arr1)  //5</span><br><span class="line">       console.log(arr)   //[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>arr.pop()</li>
</ol>
<p>删除数组中最后一个元素，会改变原数组，返回值就是删除的这个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr=[1,2,3,4]</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        var arr1=arr.pop();</span><br><span class="line">        console.log(arr1)</span><br><span class="line">        console.log(arr)</span><br></pre></td></tr></table></figure>

<p>7.arr.shift()</p>
<p>删除数组中的第一个元素，返回值就是删除的这个值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr=[1,2,3,4]</span><br><span class="line"></span><br><span class="line">        var arr1=arr.shift();</span><br><span class="line">        console.log(arr1)</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>arr.unshift(值)</li>
</ol>
<p>像数组的第一位元素前面插入一个新的元素或者多个元素，返回值就是这个新的数组的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let arr=[1,2,3,4]</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">        var arr1=arr.unshift(5,6,7);</span><br><span class="line">        console.log(arr1)</span><br><span class="line">        console.log(arr)</span><br></pre></td></tr></table></figure>

<p>10.arr.indexOf(被查找的元素，从哪里开始查找的索引)</p>
<p>查找元素，如果有的话会返回，该元素对应的索引（切忌是遇到的符合条件的第一个），如果没有的话返回-1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr=[1,2,3,4]</span><br><span class="line"></span><br><span class="line">       var arr1=arr.indexOf(1,0);</span><br><span class="line">       console.log(arr1)</span><br></pre></td></tr></table></figure>

<p>11.arr.join(‘字符串’)；</p>
<p>最后返回的是字符串，其作用是可以在每个数组元素之间添加一个该字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr=[1,2,3,4]</span><br><span class="line"></span><br><span class="line">        var arr1=arr.join(&apos;---&apos;);</span><br><span class="line">        console.log(arr1)</span><br></pre></td></tr></table></figure>

<h5 id="reverse（）"><a href="#reverse（）" class="headerlink" title="reverse（）"></a>reverse（）</h5><p>这是一个将数组元素反转的一个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr=[1,2,3,4]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  var result=arr.reverse();</span><br><span class="line">  console.log(result)</span><br></pre></td></tr></table></figure>

<h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><p>这是一个数组叠加的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4,5];</span><br><span class="line">arr.reduce(()=&gt;&#123;</span><br><span class="line">pre,next,nextindex,array</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h5><p>主要负责遍历数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">arr.forEach(item,index)&#123;</span><br><span class="line">    console.log(item,index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="map"><a href="#map" class="headerlink" title="map"></a>map</h5><p>对调用它的数组做相同的操作，（是数组的每一项），然后再返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr=[1,2,3].map(item=&gt;&#123;</span><br><span class="line">return item*2</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr)</span><br></pre></td></tr></table></figure>

<h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h5><p>满足条件的选项会被返回，返回符合条件的数组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let arr=[1,2,3,4]</span><br><span class="line"></span><br><span class="line">let filterArr=arr.filter(item=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    return item&gt;2;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="find"><a href="#find" class="headerlink" title="find"></a>find</h5><p>查找功能，只要查找到符合的那一项就不会继续查找了，并且返回被查找的那一项，如果没有找到就返回undefined</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4,5];</span><br><span class="line"></span><br><span class="line">   var result=arr.find((item)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    return item==5</span><br><span class="line"></span><br><span class="line">   &#125;)</span><br><span class="line">   console.log(result)</span><br></pre></td></tr></table></figure>

<h5 id="some"><a href="#some" class="headerlink" title="some"></a>some</h5><p>和find功能几乎一样，但是some方法返回的是一个true，（也是只要找到一个符合条件，就返回true，然后就不会在查找了）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr=[1,2,3,4,5];</span><br><span class="line"></span><br><span class="line">   var result=arr.some((item)=&gt;&#123;</span><br><span class="line"></span><br><span class="line">    return item==5</span><br><span class="line"></span><br><span class="line">   &#125;)</span><br><span class="line">   console.log(result)</span><br></pre></td></tr></table></figure>

<h5 id="every"><a href="#every" class="headerlink" title="every"></a>every</h5><p>和some功能基本一样，但是这个功能找的是false，只要遇到一个不符合操作的就结束操作，不再往下找了</p>
<h4 id="includes"><a href="#includes" class="headerlink" title="includes"></a>includes</h4><p>属于商量个方法的简写，以上三个方法可以互相替换使用</p>
<p>console.log([1,2,3,4].includes(3))</p>
<h3 id="切记"><a href="#切记" class="headerlink" title="切记"></a>切记</h3><p>arguments是数组直接使用的参数—-不需要传参！！！！！！！！ </p>
<h4 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h4><p>这是一个将类数组转换的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> let arr=[1,2,3,4]</span><br><span class="line"></span><br><span class="line">function a()&#123;</span><br><span class="line"></span><br><span class="line">    console.log(eval(Array.from(arguments).join(&apos;+&apos;)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a(1,2,3)</span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>对数组进行排序，会改变原数组，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">有固定写法</span><br><span class="line">var arr=[12,30,4,5,96,52,32];</span><br><span class="line">arr.sort(fucntion(a,b)&#123;</span><br><span class="line">if(a&gt;b)&#123;</span><br><span class="line">    return 1</span><br><span class="line">&#125;</span><br><span class="line">else if(a==b)&#123;</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    return -1</span><br><span class="line">&#125;</span><br><span class="line">&#125;)  //从小到大</span><br></pre></td></tr></table></figure>

<h4 id="arr-slice-开始的索引，结束的索引"><a href="#arr-slice-开始的索引，结束的索引" class="headerlink" title="arr.slice(开始的索引，结束的索引);"></a>arr.slice(开始的索引，结束的索引);</h4><p>从开始的地方进行截取，一直到结束的前一个索引处，不会改变原数组，返回值就是将截取的新的索引放到一个新的数组中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> let arr=[4,1,3,2,5]</span><br><span class="line"> </span><br><span class="line">var arr1=arr.slice(0,4)</span><br><span class="line">        </span><br><span class="line">        console.log(arr1)</span><br><span class="line">        console.log(arr)</span><br></pre></td></tr></table></figure>

<h4 id="arr-splice-进行操作的索引，想要干掉几个元素，插入进来的元素"><a href="#arr-splice-进行操作的索引，想要干掉几个元素，插入进来的元素" class="headerlink" title="arr.splice(进行操作的索引，想要干掉几个元素，插入进来的元素)"></a>arr.splice(进行操作的索引，想要干掉几个元素，插入进来的元素)</h4><p>一般用于删除数组中元素，或者替换元素，或者插入元素,,神方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr=[4,1,3,2,5]</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var arr1=arr.splice(1,2,&apos;x&apos;)</span><br><span class="line">        </span><br><span class="line">        console.log(arr1)</span><br><span class="line">        console.log(arr)</span><br></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> 关于数组 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[阿里经典面试题（内附详细解析哟）]]></title>
      <url>/2019/02/25/%E9%98%BF%E9%87%8C%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E5%86%85%E9%99%84%E8%AF%A6%E7%BB%86%E8%A7%A3%E6%9E%90%E5%93%9F%EF%BC%89/</url>
      <content type="html"><![CDATA[<h4 id="函数的角色"><a href="#函数的角色" class="headerlink" title="函数的角色"></a>函数的角色</h4><ol>
<li>普通函数</li>
</ol>
<p>—–》堆栈内存释放</p>
<p>—–》作用域链</p>
<ol start="2">
<li>类</li>
</ol>
<p>—–&gt;prototype :  原型</p>
<p>—-&gt;<strong>proto</strong>  :  原型链</p>
<ol start="3">
<li>普通对象</li>
</ol>
<p>——》和普通的函数没有区别–就是对键值对的的增删改查</p>
<p><strong>==&gt;       三种关系之间没有必然联系</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">实例</span><br><span class="line">function Fn()&#123;</span><br><span class="line">    var m=10;</span><br><span class="line">    this.n=20;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fn.protototype.aa=function()&#123;</span><br><span class="line">    consoleo.log(&apos;aa&apos;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fn.bb=function()&#123;</span><br><span class="line">    console.log(&apos;bb&apos;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​<br>=&gt;普通函数——-》this.n指的是window下的n，m指的是私有变量m</p>
<p>=&gt;构造函数执行的时候</p>
<p>var f=new Fn()</p>
<p>console.log(f.n)——m是Fn私有的变量和实例没有关系</p>
<p>f.n是实例的私有属性</p>
<p>f.aa实例通过prototype找到了Fn.prototype上的属性</p>
<p>f.bb是把Fn当作一个普通对象设置的属性而已，和实例没有半毛钱关系</p>
<p>=》普通对象：</p>
<p>Fn.bb是obj的属性</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>函数作为对象中使用的时候,只能对键值对进行增删改查，只能自己直接调用自己.出来的方法；不能调用prototype中的方法和属性</p>
<p>函数在作为构造函数使用的时候，实例可以调用prototype和this.出来的</p>
<p>函数作为普通函数的时候，只能使用自身的属性</p>
<h2 id="阿里巴巴关于函数的三种角色的面试题"><a href="#阿里巴巴关于函数的三种角色的面试题" class="headerlink" title="阿里巴巴关于函数的三种角色的面试题"></a>阿里巴巴关于函数的三种角色的面试题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">function Foo()&#123;</span><br><span class="line">    </span><br><span class="line">    getName=function()&#123;</span><br><span class="line">        console.log(1)</span><br><span class="line">    &#125;</span><br><span class="line">    return this</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.getName=function()&#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.prototype.getName=function()&#123;</span><br><span class="line">    </span><br><span class="line">    console.log(3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var getName=function()&#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getName()&#123;</span><br><span class="line">    console.log(5)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">问题:</span><br><span class="line"></span><br><span class="line">1.Foo.getName();          </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">getName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Foo().getName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new Foo.getName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new Foo().getName();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">new new Foo().getName();</span><br></pre></td></tr></table></figure>

<p>==2 ————————//此时把Foo当成一个对象，找到Foo的私有方法执行  </p>
<p>==4————————//由于变量提升，执行全局下的getName</p>
<p>==1————————//将getName重新赋值为1，然后return window继而调用全局下的getName（），此时的getName是1</p>
<p>==1————————//此时全局下的getName下的值为1</p>
<p>==2————————//因为无参数列表的new（）的优先级小于函数调用的优先级所以</p>
<p>==3————————//因为由参数列表的new的优先级大于函数调用的优先级，所以从左向右执行，因为是实例对象调用，所以先去构造函数身上找，当没有找到的时                候,再去prototype中去寻找</p>
<p>==3————————//先计算new Foo()，创建一个新的实例f,然后变成了  new f.getName()，然后执行f.getName最后再把执行后的结果new一下，其实就相当于把                            f.getName()当作一个类，然后再返回这个类的实例</p>
]]></content>
      
        
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
